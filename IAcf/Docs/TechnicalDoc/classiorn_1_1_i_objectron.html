<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>IACF: iorn::IObjectron Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">IACF
   &#160;<span id="projectnumber">0.3.2.41</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceiorn.html">iorn</a>      </li>
      <li class="navelem"><a class="el" href="classiorn_1_1_i_objectron.html">IObjectron</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">iorn::IObjectron Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="iorn::IObjectron" --><!-- doxytag: inherits="iser::ISerializable" -->
<p>Interface defining objectron.  
 <a href="classiorn_1_1_i_objectron.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_i_objectron_8h_source.html">IObjectron.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for iorn::IObjectron:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classiorn_1_1_i_objectron.png" usemap="#iorn::IObjectron_map" alt=""/>
  <map id="iorn::IObjectron_map" name="iorn::IObjectron_map">
<area doxygen="Package.tag:file:\\C:\Temp\Acf/Docs/TechnicalDoc/" href="file:\\C:\Temp\Acf/Docs/TechnicalDoc/classiser_1_1_i_serializable.html" alt="iser::ISerializable" shape="rect" coords="0,112,191,136"/>
<area doxygen="Package.tag:file:\\C:\Temp\Acf/Docs/TechnicalDoc/" href="file:\\C:\Temp\Acf/Docs/TechnicalDoc/classistd_1_1_i_changeable.html" alt="istd::IChangeable" shape="rect" coords="0,56,191,80"/>
<area doxygen="Package.tag:file:\\C:\Temp\Acf/Docs/TechnicalDoc/" href="file:\\C:\Temp\Acf/Docs/TechnicalDoc/classistd_1_1_i_polymorphic.html" alt="istd::IPolymorphic" shape="rect" coords="0,0,191,24"/>
<area href="classiorn_1_1_c_sigmoidal_objectron_comp.html" alt="iorn::CSigmoidalObjectronComp" shape="rect" coords="0,224,191,248"/>
</map>
 </div></div>

<p><a href="classiorn_1_1_i_objectron-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiorn_1_1_i_objectron.html#a6ee1e7d089768a9605be51968d6dd889">QualityQuery</a> { <br/>
&#160;&#160;<a class="el" href="classiorn_1_1_i_objectron.html#a6ee1e7d089768a9605be51968d6dd889a824add5ab5ab1c475422baab42cce372">QQ_PROCESSING</a>, 
<a class="el" href="classiorn_1_1_i_objectron.html#a6ee1e7d089768a9605be51968d6dd889aec26367fd8ac5c496ed0acacee96dadf">QQ_BACKPROPAGATION</a>, 
<a class="el" href="classiorn_1_1_i_objectron.html#a6ee1e7d089768a9605be51968d6dd889a34dd03b6e8c227b4ea02dc7f152e49b2">QQ_BACKPROPAGATION_INPUT</a>, 
<a class="el" href="classiorn_1_1_i_objectron.html#a6ee1e7d089768a9605be51968d6dd889a8b7cddbaae07f5b188464624b0edd271">QQ_ERROR_BACKPROPAGATION</a>, 
<br/>
&#160;&#160;<a class="el" href="classiorn_1_1_i_objectron.html#a6ee1e7d089768a9605be51968d6dd889ae609eb73ecc7d78fb66d719e61276e0c">QQ_PROGRESSIVE_LEARNING</a>, 
<a class="el" href="classiorn_1_1_i_objectron.html#a6ee1e7d089768a9605be51968d6dd889a8283f489936f365dc3925263d668e9cb">QQ_UNSUPERVISED_LEARNING</a>, 
<a class="el" href="classiorn_1_1_i_objectron.html#a6ee1e7d089768a9605be51968d6dd889aa7b853cc8d119af4e3ab0fe7f47759ca">QQ_EXAMPLE_LEARNING</a>, 
<a class="el" href="classiorn_1_1_i_objectron.html#a6ee1e7d089768a9605be51968d6dd889a998dae3c2900b650dc1849a61f7670b0">QQ_CRITIC_LEARNING</a>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiorn_1_1_i_objectron.html#ad59c973ff75bbbef0cac8b9a6329e46b">GetOperationQuality</a> (int qualityQuery) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiorn_1_1_i_objectron.html#aa2f4b6a696a0194341a207109b14acf6">ProcessHypotheses</a> (const <a class="el" href="classiorn_1_1_c_hypotheses_set.html">CHypothesesSet</a> &amp;inputSet, <a class="el" href="classiorn_1_1_c_hypotheses_set.html">CHypothesesSet</a> &amp;outputSet) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get output hypothesis set.  <a href="#aa2f4b6a696a0194341a207109b14acf6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiorn_1_1_i_objectron.html#a71cf187df34b00c45e1c24cf8e5d54ca">BackpropagateHypotheses</a> (const <a class="el" href="classiorn_1_1_c_hypotheses_set.html">CHypothesesSet</a> *inputSetPtr, const <a class="el" href="classiorn_1_1_c_hypotheses_set.html">CHypothesesSet</a> &amp;outputSet, <a class="el" href="classiorn_1_1_c_hypotheses_set.html">CHypothesesSet</a> &amp;approxInputSet) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get approximation of input hypothesis set from the output and (optional) suggested input.  <a href="#a71cf187df34b00c45e1c24cf8e5d54ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiorn_1_1_i_objectron.html#a1772e3b04c5757bb8c195ff6fff1f1c2">BackpropagateError</a> (const <a class="el" href="classiorn_1_1_c_hypotheses_set.html">CHypothesesSet</a> &amp;inputSet, double outputError, double &amp;approxInputError, double &amp;approxQuality) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get approximation of input error propagated from output.  <a href="#a1772e3b04c5757bb8c195ff6fff1f1c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classiorn_1_1_i_objectron.html#a438a199c4a6e1cfe548a792d1850fada">DoLearning</a> (const <a class="el" href="classiorn_1_1_i_learning_set.html">ILearningSet</a> &amp;learningSet, const <a class="el" href="classiorn_1_1_i_learn_feedback.html">ILearnFeedback</a> *learnFeedbackPtr, bool isProgressive=false)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Do learning process.  <a href="#a438a199c4a6e1cfe548a792d1850fada"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Interface defining objectron. </p>
<p>Objectron is something like layer in neural network, it has similiar behaviuor on interface level. It can calculate the output from input. It can be leaned self-associative or based on teached learning - it depends on implementation. The main difference to ANN is that objectron defines no assumption about internal realisation of this interface. It means classic algebraic realisation can be used, some recursive combinations of slave objectrons etc. Objectron is serializable, its state is determined by learning process. </p>

<p>Definition at line <a class="el" href="_i_objectron_8h_source.html#l00029">29</a> of file <a class="el" href="_i_objectron_8h_source.html">IObjectron.h</a>.</p>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a6ee1e7d089768a9605be51968d6dd889"></a><!-- doxytag: member="iorn::IObjectron::QualityQuery" ref="a6ee1e7d089768a9605be51968d6dd889" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classiorn_1_1_i_objectron.html#a6ee1e7d089768a9605be51968d6dd889">iorn::IObjectron::QualityQuery</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a6ee1e7d089768a9605be51968d6dd889a824add5ab5ab1c475422baab42cce372"></a><!-- doxytag: member="QQ_PROCESSING" ref="a6ee1e7d089768a9605be51968d6dd889a824add5ab5ab1c475422baab42cce372" args="" -->QQ_PROCESSING</em>&nbsp;</td><td>
<p>General quality of this processing method. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6ee1e7d089768a9605be51968d6dd889aec26367fd8ac5c496ed0acacee96dadf"></a><!-- doxytag: member="QQ_BACKPROPAGATION" ref="a6ee1e7d089768a9605be51968d6dd889aec26367fd8ac5c496ed0acacee96dadf" args="" -->QQ_BACKPROPAGATION</em>&nbsp;</td><td>
<p>Backpropagation of hypotheses without input data. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6ee1e7d089768a9605be51968d6dd889a34dd03b6e8c227b4ea02dc7f152e49b2"></a><!-- doxytag: member="QQ_BACKPROPAGATION_INPUT" ref="a6ee1e7d089768a9605be51968d6dd889a34dd03b6e8c227b4ea02dc7f152e49b2" args="" -->QQ_BACKPROPAGATION_INPUT</em>&nbsp;</td><td>
<p>Backpropagation of hypotheses with input data. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6ee1e7d089768a9605be51968d6dd889a8b7cddbaae07f5b188464624b0edd271"></a><!-- doxytag: member="QQ_ERROR_BACKPROPAGATION" ref="a6ee1e7d089768a9605be51968d6dd889a8b7cddbaae07f5b188464624b0edd271" args="" -->QQ_ERROR_BACKPROPAGATION</em>&nbsp;</td><td>
<p>Backpropagation of error. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6ee1e7d089768a9605be51968d6dd889ae609eb73ecc7d78fb66d719e61276e0c"></a><!-- doxytag: member="QQ_PROGRESSIVE_LEARNING" ref="a6ee1e7d089768a9605be51968d6dd889ae609eb73ecc7d78fb66d719e61276e0c" args="" -->QQ_PROGRESSIVE_LEARNING</em>&nbsp;</td><td>
<p>Progressive learning. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6ee1e7d089768a9605be51968d6dd889a8283f489936f365dc3925263d668e9cb"></a><!-- doxytag: member="QQ_UNSUPERVISED_LEARNING" ref="a6ee1e7d089768a9605be51968d6dd889a8283f489936f365dc3925263d668e9cb" args="" -->QQ_UNSUPERVISED_LEARNING</em>&nbsp;</td><td>
<p>Unsupervised learning. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6ee1e7d089768a9605be51968d6dd889aa7b853cc8d119af4e3ab0fe7f47759ca"></a><!-- doxytag: member="QQ_EXAMPLE_LEARNING" ref="a6ee1e7d089768a9605be51968d6dd889aa7b853cc8d119af4e3ab0fe7f47759ca" args="" -->QQ_EXAMPLE_LEARNING</em>&nbsp;</td><td>
<p>Supervised learning with examples. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6ee1e7d089768a9605be51968d6dd889a998dae3c2900b650dc1849a61f7670b0"></a><!-- doxytag: member="QQ_CRITIC_LEARNING" ref="a6ee1e7d089768a9605be51968d6dd889a998dae3c2900b650dc1849a61f7670b0" args="" -->QQ_CRITIC_LEARNING</em>&nbsp;</td><td>
<p>Supervised learning with critic. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="_i_objectron_8h_source.html#l00032">32</a> of file <a class="el" href="_i_objectron_8h_source.html">IObjectron.h</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1772e3b04c5757bb8c195ff6fff1f1c2"></a><!-- doxytag: member="iorn::IObjectron::BackpropagateError" ref="a1772e3b04c5757bb8c195ff6fff1f1c2" args="(const CHypothesesSet &amp;inputSet, double outputError, double &amp;approxInputError, double &amp;approxQuality) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool iorn::IObjectron::BackpropagateError </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiorn_1_1_c_hypotheses_set.html">CHypothesesSet</a> &amp;&#160;</td>
          <td class="paramname"><em>inputSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>outputError</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>approxInputError</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>approxQuality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get approximation of input error propagated from output. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if calculation of error failed or this operation is not supported. </dd></dl>

<p>Implemented in <a class="el" href="classiorn_1_1_c_sigmoidal_objectron_comp.html#ae8d68c9e2fae1b47e0a03978e5ee5fbd">iorn::CSigmoidalObjectronComp</a>.</p>

</div>
</div>
<a class="anchor" id="a71cf187df34b00c45e1c24cf8e5d54ca"></a><!-- doxytag: member="iorn::IObjectron::BackpropagateHypotheses" ref="a71cf187df34b00c45e1c24cf8e5d54ca" args="(const CHypothesesSet *inputSetPtr, const CHypothesesSet &amp;outputSet, CHypothesesSet &amp;approxInputSet) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool iorn::IObjectron::BackpropagateHypotheses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiorn_1_1_c_hypotheses_set.html">CHypothesesSet</a> *&#160;</td>
          <td class="paramname"><em>inputSetPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiorn_1_1_c_hypotheses_set.html">CHypothesesSet</a> &amp;&#160;</td>
          <td class="paramname"><em>outputSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiorn_1_1_c_hypotheses_set.html">CHypothesesSet</a> &amp;&#160;</td>
          <td class="paramname"><em>approxInputSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get approximation of input hypothesis set from the output and (optional) suggested input. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inputSetPtr</td><td>optional suggested input set. </td></tr>
    <tr><td class="paramname">outputSet</td><td>output set should used as input data for backpropagation. </td></tr>
    <tr><td class="paramname">approxInputSet</td><td>result of this operation - approximated input data set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if calculation of hypotheses failed or this operation is not supported. </dd></dl>

<p>Implemented in <a class="el" href="classiorn_1_1_c_sigmoidal_objectron_comp.html#a35988b9bcc08b79a2af5ec20014703e8">iorn::CSigmoidalObjectronComp</a>.</p>

</div>
</div>
<a class="anchor" id="a438a199c4a6e1cfe548a792d1850fada"></a><!-- doxytag: member="iorn::IObjectron::DoLearning" ref="a438a199c4a6e1cfe548a792d1850fada" args="(const ILearningSet &amp;learningSet, const ILearnFeedback *learnFeedbackPtr, bool isProgressive=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int iorn::IObjectron::DoLearning </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiorn_1_1_i_learning_set.html">ILearningSet</a> &amp;&#160;</td>
          <td class="paramname"><em>learningSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classiorn_1_1_i_learn_feedback.html">ILearnFeedback</a> *&#160;</td>
          <td class="paramname"><em>learnFeedbackPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isProgressive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Do learning process. </p>
<p>There are generally two kinds of learning: supervised and unsupervised. For supervised learning you have to provide <code><a class="el" href="classiorn_1_1_i_learn_feedback.html" title="Allow to calculate output for supervised learning.">ILearnFeedback</a></code> object used to retrive supervisor information. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inputLearningSet</td><td>set of learning input examples. </td></tr>
    <tr><td class="paramname">learnFeedbackPtr</td><td>pointer to learn feedback. It is necessary for supervised learning. </td></tr>
    <tr><td class="paramname">isProgressive</td><td>if true, the progressive learning is enabled, it means only correction of current state should be done. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classiorn_1_1_c_sigmoidal_objectron_comp.html#a46c1610e2bb115db2369e587eb6b3912">iorn::CSigmoidalObjectronComp</a>.</p>

</div>
</div>
<a class="anchor" id="ad59c973ff75bbbef0cac8b9a6329e46b"></a><!-- doxytag: member="iorn::IObjectron::GetOperationQuality" ref="ad59c973ff75bbbef0cac8b9a6329e46b" args="(int qualityQuery) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double iorn::IObjectron::GetOperationQuality </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qualityQuery</em></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implemented in <a class="el" href="classiorn_1_1_c_sigmoidal_objectron_comp.html#a0ae30801130e85296d00fdff8ede7392">iorn::CSigmoidalObjectronComp</a>.</p>

</div>
</div>
<a class="anchor" id="aa2f4b6a696a0194341a207109b14acf6"></a><!-- doxytag: member="iorn::IObjectron::ProcessHypotheses" ref="aa2f4b6a696a0194341a207109b14acf6" args="(const CHypothesesSet &amp;inputSet, CHypothesesSet &amp;outputSet) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool iorn::IObjectron::ProcessHypotheses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classiorn_1_1_c_hypotheses_set.html">CHypothesesSet</a> &amp;&#160;</td>
          <td class="paramname"><em>inputSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classiorn_1_1_c_hypotheses_set.html">CHypothesesSet</a> &amp;&#160;</td>
          <td class="paramname"><em>outputSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get output hypothesis set. </p>
<p>This set is the product of objectron processing. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inputSet</td><td>set of possible input hypothesis. </td></tr>
    <tr><td class="paramname">outputSet</td><td>set of possible output hypothesis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if calculation of hypotheses failed. </dd></dl>

<p>Implemented in <a class="el" href="classiorn_1_1_c_sigmoidal_objectron_comp.html#a724c00b839869ebb8298942ad510fc41">iorn::CSigmoidalObjectronComp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Temp/Iacf/Include/iorn/<a class="el" href="_i_objectron_8h_source.html">IObjectron.h</a></li>
</ul>
</div>
<P ALIGN=RIGHT STYLE="margin-bottom: 0cm">&copy; 2007-2011 Witold
Gantzke and Kirill Lepskiy</P>
</BODY>
</HTML>
