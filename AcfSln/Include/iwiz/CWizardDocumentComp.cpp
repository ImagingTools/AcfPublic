/********************************************************************************
**
**	Copyright (c) 2007-2011 Witold Gantzke & Kirill Lepskiy
**
**	This file is part of the ACF-Solutions Toolkit.
**
**	This file may be used under the terms of the GNU Lesser
**	General Public License version 2.1 as published by the Free Software
**	Foundation and appearing in the file LicenseLGPL.txt included in the
**	packaging of this file.  Please review the following information to
**	ensure the GNU Lesser General Public License version 2.1 requirements
**	will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
**	If you are unsure which license is appropriate for your use, please
**	contact us at info@imagingtools.de.
**
** 	See http://www.ilena.org, write info@imagingtools.de or contact
**	by Skype to ACF_infoline for further information about the ACF-Solutions.
**
********************************************************************************/


#include "iwiz/CWizardDocumentComp.h"


// ACF includes
#include "istd/TChangeNotifier.h"

#include "iproc/IStateController.h"


namespace iwiz
{


// reimplemented (iwiz::IParamsManagerWizard)

bool CWizardDocumentComp::IsPageSelectionAllowed(int pageIndex) const
{
	if ((pageIndex < 0) || (pageIndex >= GetParamsSetsCount())){
		return false;
	}

	int currentPageIndex = GetSelectedOptionIndex();

	const iproc::IStateController* destPageInfoPtr = CompCastPtr<const iproc::IStateController>(GetParamsSet(pageIndex));
	if ((destPageInfoPtr != NULL) && !destPageInfoPtr->IsStateEnabled()){
		return false;
	}

	for (		int checkPageIndex = qMax(currentPageIndex, 0);
				checkPageIndex < pageIndex;
				++checkPageIndex){
		const iproc::IStateController* checkedPageInfoPtr = CompCastPtr<const iproc::IStateController>(GetParamsSet(checkPageIndex));
		if ((checkedPageInfoPtr != NULL) && checkedPageInfoPtr->IsStateEnabled() && !checkedPageInfoPtr->IsLeaveAllowed()){
			return false;
		}
	}

	return true;
}


// reimplemented (iwiz::IWizardNavigationController)

bool CWizardDocumentComp::IsFinishAllowed() const
{
	int pagesCount = GetParamsSetsCount();

	for (int checkPageIndex = 0; checkPageIndex < pagesCount; ++checkPageIndex){
		const iproc::IStateController* checkedPageInfoPtr = CompCastPtr<const iproc::IStateController>(GetParamsSet(checkPageIndex));
		if ((checkedPageInfoPtr != NULL) && checkedPageInfoPtr->IsStateEnabled() && !checkedPageInfoPtr->IsLeaveAllowed()){
			return false;
		}
	}

	return true;
}


int CWizardDocumentComp::GetPrevPageIndex() const
{
	int currentPageIndex = GetSelectedOptionIndex();

	for (int checkPageIndex = currentPageIndex - 1; checkPageIndex >= 0; --checkPageIndex){
		const iproc::IStateController* checkedPageInfoPtr = CompCastPtr<const iproc::IStateController>(GetParamsSet(checkPageIndex));
		if ((checkedPageInfoPtr == NULL) || checkedPageInfoPtr->IsStateEnabled()){
			return checkPageIndex;
		}
	}

	return currentPageIndex;
}


int CWizardDocumentComp::GetNextPageIndex() const
{
	int pagesCount = GetParamsSetsCount();
	int currentPageIndex = GetSelectedOptionIndex();

	if (currentPageIndex >= 0){
		const iproc::IStateController* currentPageInfoPtr = CompCastPtr<const iproc::IStateController>(GetParamsSet(currentPageIndex));
		if ((currentPageInfoPtr != NULL) && !currentPageInfoPtr->IsLeaveAllowed()){
			return currentPageIndex;
		}
	}

	for (int checkPageIndex = currentPageIndex + 1; checkPageIndex < pagesCount; ++checkPageIndex){
		const iproc::IStateController* checkedPageInfoPtr = CompCastPtr<const iproc::IStateController>(GetParamsSet(checkPageIndex));
		if ((checkedPageInfoPtr == NULL) || checkedPageInfoPtr->IsStateEnabled()){
			return checkPageIndex;
		}
	}

	return -1;
}


bool CWizardDocumentComp::DoWizardFinish()
{
	int pagesCount = GetParamsSetsCount();
	int currentPageIndex = GetSelectedOptionIndex();

	istd::CChangeNotifier notifier(this);

	for (int checkPageIndex = currentPageIndex + 1; checkPageIndex < pagesCount; ++checkPageIndex){
		iproc::IStateController* checkedPageInfoPtr = CompCastPtr<iproc::IStateController>(GetParamsSet(checkPageIndex));
		if ((checkedPageInfoPtr == NULL) || !checkedPageInfoPtr->IsStateEnabled()){
			continue;
		}

		if (!SetSelectedOptionIndex(checkPageIndex)){
			return false;
		}
	}

	iproc::IStateController* currentPageInfoPtr = CompCastPtr<iproc::IStateController>(GetParamsSet(currentPageIndex));
	if (currentPageInfoPtr != NULL){
		if (!currentPageInfoPtr->TryLeaveState(true, NULL)){
			return false;
		}
	}

	return true;
}


// reimplemented (iprm::ISelectionParam)

bool CWizardDocumentComp::SetSelectedOptionIndex(int index)
{
	int currentPageIndex = BaseClass::GetSelectedOptionIndex();
	if (index == currentPageIndex){
		return true;
	}

	if (!IsPageSelectionAllowed(index)){
		return false;
	}

	int pagesCount = GetParamsSetsCount();

	iproc::IStateController* currentPageInfoPtr = NULL;
	if ((currentPageIndex >= 0) && (currentPageIndex < pagesCount)){
		currentPageInfoPtr = CompCastPtr<iproc::IStateController>(GetParamsSet(currentPageIndex));
	}

	iproc::IStateController* nextPageInfoPtr = NULL;
	if ((index >= 0) && (index < pagesCount)){
		nextPageInfoPtr = CompCastPtr<iproc::IStateController>(GetParamsSet(index));
	}

	istd::CChangeNotifier notifier(this);

	bool isNextPage = (index == GetNextPageIndex());

	if (currentPageInfoPtr != NULL){
		if (!currentPageInfoPtr->TryLeaveState(isNextPage, nextPageInfoPtr)){
			return false;
		}
	}

	if ((nextPageInfoPtr == NULL) || nextPageInfoPtr->TryEnterState(isNextPage, currentPageInfoPtr)){
		return BaseClass::SetSelectedOptionIndex(index);
	}
	else{
		BaseClass::SetSelectedOptionIndex(-1);
		return false;
	}
}


// reimplemented (iser::ISerializable)

bool CWizardDocumentComp::Serialize(iser::IArchive& archive)
{
	bool isStoring = archive.IsStoring();
	istd::CChangeNotifier notifier(isStoring? NULL: this);

	int pagesCount = GetParamsSetsCount();

	if (!isStoring){
		int currentPageIndex = BaseClass::GetSelectedOptionIndex();

		iproc::IStateController* currentPageInfoPtr = NULL;
		if ((currentPageIndex >= 0) && (currentPageIndex < pagesCount)){
			currentPageInfoPtr = CompCastPtr<iproc::IStateController>(GetParamsSet(currentPageIndex));
		}

		if (currentPageInfoPtr != NULL){
			currentPageInfoPtr->TryLeaveState(false);
		}
	}

	bool retVal = true;
	if (m_additionalObjectsCompPtr.IsValid())
	{
		static iser::CArchiveTag additionalObjectsTag("AdditionalObjects", "Additional persistent objects");
		retVal = retVal && archive.BeginTag(additionalObjectsTag);
		int count = m_additionalObjectsCompPtr.GetCount();
		for (int index = 0; retVal && (index < count); ++index)
		{
			retVal = retVal && m_additionalObjectsCompPtr[index]->Serialize(archive);
		}
		retVal = retVal && archive.EndTag(additionalObjectsTag);
	}

	retVal = retVal && SerializeParamSets(archive);

	if (!isStoring){
		int index = BaseClass::GetSelectedOptionIndex();

		iproc::IStateController* nextPageInfoPtr = NULL;
		if ((index >= 0) && (index < pagesCount)){
			nextPageInfoPtr = CompCastPtr<iproc::IStateController>(GetParamsSet(index));
		}

		if ((nextPageInfoPtr == NULL) || nextPageInfoPtr->TryEnterState(false)){
			BaseClass::SetSelectedOptionIndex(index);
		}
		else{
			BaseClass::SetSelectedOptionIndex(-1);
		}
	}

	return retVal;
}


// protected methods

bool CWizardDocumentComp::SerializeParamSets(iser::IArchive& archive)
{
	return BaseClass::Serialize(archive);
}


// reimplemented (icomp::CComponentBase)

void CWizardDocumentComp::OnComponentCreated()
{
	if (m_defaultPageIndexAttrPtr.IsValid()){
		SetSelectedOptionIndex(*m_defaultPageIndexAttrPtr);
	}

	BaseClass::OnComponentCreated();
}


} // namespace iwiz


