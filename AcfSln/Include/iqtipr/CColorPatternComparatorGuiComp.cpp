/********************************************************************************
**
**	Copyright (c) 2007-2014 Witold Gantzke & Kirill Lepskiy
**
**	This file is part of the ACF-Solutions Toolkit.
**
**	This file may be used under the terms of the GNU Lesser
**	General Public License version 2.1 as published by the Free Software
**	Foundation and appearing in the file LicenseLGPL.txt included in the
**	packaging of this file.  Please review the following information to
**	ensure the GNU Lesser General Public License version 2.1 requirements
**	will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
**	If you are unsure which license is appropriate for your use, please
**	contact us at info@imagingtools.de.
**
** 	See http://www.ilena.org, write info@imagingtools.de or contact
**	by Skype to ACF_infoline for further information about the ACF-Solutions.
**
********************************************************************************/


#include "iqtipr/CColorPatternComparatorGuiComp.h"

// ACF includes
#include "imeas/IDataSequenceProvider.h"
#include "iprm/IEnableableParam.h"
#include "iprm/TParamsPtr.h"


namespace iqtipr
{


// protected slots

void CColorPatternComparatorGuiComp::on_TestButton_clicked()
{
	DoTest();
}


void CColorPatternComparatorGuiComp::on_TaskEnabledCB_toggled(bool)
{
	UpdateModel();
}


// protected methods

// reimplemented (iqtgui::TGuiObserverWrap)

void CColorPatternComparatorGuiComp::OnGuiCreated()
{
	BaseClass::OnGuiCreated();

	TaskEnabledCB->hide();
}


void CColorPatternComparatorGuiComp::UpdateModel()
{
	const imeas::INumericValueProvider* numericValueProviderPtr = CompCastPtr<const imeas::INumericValueProvider>(GetObjectPtr());
	if (numericValueProviderPtr != NULL){
		const iinsp::ISupplier* supplierPtr = dynamic_cast<const iinsp::ISupplier*>(numericValueProviderPtr);
		if (supplierPtr != NULL){
			iprm::TParamsPtr<iprm::IEnableableParam> checkEnabledPtr(supplierPtr->GetModelParametersSet(), *m_taskEnabledIdAttrPtr); 
			if (checkEnabledPtr.IsValid()){
				(const_cast<iprm::IEnableableParam*>(checkEnabledPtr.GetPtr()))->SetEnabled(TaskEnabledCB->isChecked());
			}
		}
	}
}


void CColorPatternComparatorGuiComp::UpdateGui(const istd::IChangeable::ChangeSet& changeSet)
{
	BaseClass::UpdateGui(changeSet);

	while (ColorTable->rowCount()){
		ColorTable->removeRow(0);
	}

	Q_ASSERT(IsGuiCreated());

	const imeas::INumericValueProvider* numericValueProviderPtr = CompCastPtr<const imeas::INumericValueProvider>(GetObjectPtr());
	if (numericValueProviderPtr != NULL){
		const iinsp::ISupplier* supplierPtr = dynamic_cast<const iinsp::ISupplier*>(numericValueProviderPtr);
		if (supplierPtr != NULL){
			// if the task is disabled: no check in this case
			iprm::TParamsPtr<iprm::IEnableableParam> checkEnabledPtr(supplierPtr->GetModelParametersSet(), *m_taskEnabledIdAttrPtr); 
			if (checkEnabledPtr.IsValid()){
				TaskEnabledCB->show();
				TaskEnabledCB->setChecked(checkEnabledPtr->IsEnabled());
				if (!checkEnabledPtr->IsEnabled()){
					return;
				}
			}
		}

		int valuesCount = numericValueProviderPtr->GetValuesCount();
		if (valuesCount > 0){
			const imeas::INumericValue& value = numericValueProviderPtr->GetNumericValue(0);

			const imath::CVarVector& colorValues = value.GetValues();
			int colorValuesCount = colorValues.GetElementsCount();

			if (colorValuesCount == 2){
				QTableWidgetItem* workingColorItem = new QTableWidgetItem(QString::number(colorValues[0]));
				QTableWidgetItem* teachedColorItem = new QTableWidgetItem(QString::number(colorValues[1]));
				workingColorItem->setFlags(Qt::ItemIsSelectable | Qt::ItemIsEnabled);
				teachedColorItem->setFlags(Qt::ItemIsSelectable | Qt::ItemIsEnabled);

				double delta = colorValues[1] - colorValues[0];
				double deltaRel = abs(delta) / 255;
				QTableWidgetItem* diffItem = new QTableWidgetItem(QString("%1 (%2%)").arg(delta).arg(deltaRel*100, 0, 'g', 2));

				ColorTable->setRowCount(1);
				ColorTable->setItem(0, 0, workingColorItem);
				ColorTable->setItem(0, 1, teachedColorItem);
				ColorTable->setItem(0, 2, diffItem);

				ColorTable->verticalHeaderItem(0)->setText(tr("Grayvalue"));
			}
			else if(colorValuesCount == 6){
				ColorTable->setRowCount(3);

			#if QT_VERSION < 0x050000
				ColorTable->verticalHeader()->setResizeMode(QHeaderView::Stretch);
			#else
				ColorTable->verticalHeader()->setSectionResizeMode(QHeaderView::Stretch);
			#endif

				ColorTable->setVerticalHeaderItem(0, new QTableWidgetItem(tr("Hue")));
				ColorTable->setVerticalHeaderItem(1, new QTableWidgetItem(tr("Saturation")));
				ColorTable->setVerticalHeaderItem(2, new QTableWidgetItem(tr("Value")));

				for (int i = 0; i < 3; i++){
					double currentValue = colorValues[i];
					double teachedValue = colorValues[i + 3];

					QTableWidgetItem* workingColorItem = new QTableWidgetItem(QString::number(currentValue));
					QTableWidgetItem* teachedColorItem = new QTableWidgetItem(QString::number(teachedValue));
					workingColorItem->setFlags(Qt::ItemIsSelectable | Qt::ItemIsEnabled);
					teachedColorItem->setFlags(Qt::ItemIsSelectable | Qt::ItemIsEnabled);

					double delta = teachedValue - currentValue;
					double deltaRel = abs(delta) / 255;
					QTableWidgetItem* diffItem = new QTableWidgetItem(QString("%1 (%2%)").arg(delta).arg(deltaRel*100, 0, 'g', 2));

					ColorTable->setItem(i, 0, workingColorItem);
					ColorTable->setItem(i, 1, teachedColorItem);
					ColorTable->setItem(i, 2, diffItem);
				}
			}
		}
	}
}


// reimplemented (iqtinsp::TSupplierGuiCompBase)

void CColorPatternComparatorGuiComp::OnSupplierParamsChanged()
{
	if (IsGuiCreated()){
		if (AutoUpdateButton->isChecked()){
			on_TestButton_clicked();
		}

		istd::IChangeable::ChangeSet changeSet;
		UpdateGui(changeSet);
	}
}


QWidget* CColorPatternComparatorGuiComp::GetParamsWidget() const
{
	Q_ASSERT(IsGuiCreated());

	return ParametersFrame;
}


} // namespace iqtipr


