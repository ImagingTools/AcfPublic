/********************************************************************************
**
**	Copyright (C) 2007-2017 Witold Gantzke & Kirill Lepskiy
**
**	This file is part of the ACF-Solutions Toolkit.
**
**	This file may be used under the terms of the GNU Lesser
**	General Public License version 2.1 as published by the Free Software
**	Foundation and appearing in the file LicenseLGPL.txt included in the
**	packaging of this file.  Please review the following information to
**	ensure the GNU Lesser General Public License version 2.1 requirements
**	will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
**	If you are unsure which license is appropriate for your use, please
**	contact us at info@imagingtools.de.
**
** 	See http://www.ilena.org or write info@imagingtools.de for further
** 	information about the ACF.
**
********************************************************************************/


#include <iprocgui/CDocumentProcessingManagerCompBase.h>


// ACF includes
#include <iqtgui/CGuiComponentDialog.h>


namespace iprocgui
{


// public methods

CDocumentProcessingManagerCompBase::CDocumentProcessingManagerCompBase()
:	m_rootCommands("", 100, ibase::ICommand::CF_GLOBAL_MENU),
	m_processingCommand("", 100, ibase::ICommand::CF_GLOBAL_MENU)
{
}


bool CDocumentProcessingManagerCompBase::IsInputDocumentRequired() const
{
	bool retVal = true;

	if (m_inputDocumentRequiredAttrPtr.IsValid()){
		retVal = *m_inputDocumentRequiredAttrPtr;
	}

	return retVal;
}


void CDocumentProcessingManagerCompBase::SetProcessingCommandEnabled(bool isProcessingCommandEnabled)
{
	m_processingCommand.setEnabled(isProcessingCommandEnabled);
}


// reimpemented (ibase::ICommandsProvider)

const ibase::IHierarchicalCommand* CDocumentProcessingManagerCompBase::GetCommands() const
{
	return &m_processingMenu;
}


// reimpemented (icomp::IComponent)

void CDocumentProcessingManagerCompBase::OnComponentCreated()
{
	BaseClass::OnComponentCreated();

	if (m_documentManagerModelCompPtr.IsValid()){
		RegisterModel(m_documentManagerModelCompPtr.GetPtr());
	}
	
	QString menuName;

	if (m_menuNameAttrPtr.IsValid()){
		menuName = *m_menuNameAttrPtr;
	}

	if (m_commandNameAttrPtr.IsValid() && !(*m_commandNameAttrPtr).isEmpty()){
		QString commandName = *m_commandNameAttrPtr;

		QIcon commandIcon;

		if (m_commandIconPathAttrPtr.IsValid()){
			commandIcon = QIcon(*m_commandIconPathAttrPtr);
		}
		
		if (*m_commandShowInToolBarAttrPtr){
			m_processingCommand.SetStaticFlags(m_processingCommand.GetStaticFlags() | ibase::ICommand::CF_TOOLBAR);
		}

		m_processingCommand.SetGroupId(*m_commandGroupIdAttrPtr);
	
		m_processingCommand.SetVisuals(commandName, commandName, commandName, commandIcon);

		m_rootCommands.SetVisuals(menuName, menuName, tr("Document processing actions"));
		m_rootCommands.InsertChild(&m_processingCommand);
		m_processingMenu.InsertChild(&m_rootCommands);

		connect(&m_processingCommand, SIGNAL(triggered()), this, SLOT(OnDoProcessing()));
	}
}


void CDocumentProcessingManagerCompBase::OnComponentDestroyed()
{
	UnregisterAllModels();

	BaseClass::OnComponentDestroyed();
}


// protected methods

// reimplemented (imod::CMultiModelDispatcherBase)

void CDocumentProcessingManagerCompBase::OnModelChanged(int modelId, const istd::IChangeable::ChangeSet& /*changeSet*/)
{
	idoc::IDocumentManager* objectPtr = GetObjectAt<idoc::IDocumentManager>(modelId);
	Q_ASSERT(objectPtr != NULL);
	if (objectPtr != NULL){
		SetProcessingCommandEnabled((objectPtr->GetActiveView() != NULL) || !IsInputDocumentRequired());
	}
}


// private slots

void CDocumentProcessingManagerCompBase::OnDoProcessing()
{
	if (!m_documentManagerCompPtr.IsValid()){
		SendErrorMessage(0, "Document manager was not set", "Document processing manager");

		return;
	}

	if (!m_processorCompPtr.IsValid()){
		SendErrorMessage(0, "Processor was not set", "Document processing manager");

		return;
	}

	bool inputDocumentRequired = IsInputDocumentRequired();

	istd::IPolymorphic* viewPtr = m_documentManagerCompPtr->GetActiveView();
	if ((viewPtr == NULL) && inputDocumentRequired){
		return;
	}

	istd::IChangeable* inputDocumentPtr = m_documentManagerCompPtr->GetDocumentFromView(*viewPtr);
	if ((inputDocumentPtr == NULL) && inputDocumentRequired){
		return;
	}
	
	QByteArray documentTypeId;
	if (inputDocumentPtr != NULL){
		documentTypeId = m_documentManagerCompPtr->GetDocumentTypeId(*inputDocumentPtr);
	}
	
	if (m_documentTypeIdAttrPtr.IsValid())
	{
		documentTypeId = *m_documentTypeIdAttrPtr;
	}


	istd::TDelPtr<iqtgui::CGuiComponentDialog> dialogPtr;

	if (m_paramsGuiCompPtr.IsValid()){
		dialogPtr.SetPtr(
					new iqtgui::CGuiComponentDialog(
								m_paramsGuiCompPtr.GetPtr(),
								QDialogButtonBox::Ok | QDialogButtonBox::Cancel,
								true));

		int retVal = dialogPtr->exec();
		if (retVal != QDialog::Accepted){
			return;
		}
	}

	// Force model update:
	dialogPtr.Reset();

	// Process document:
	DoDocumentProcessing(inputDocumentPtr, documentTypeId);
}


} // namespace iprocgui


