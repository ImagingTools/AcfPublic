/********************************************************************************
**
**	Copyright (c) 2007-2011 Witold Gantzke & Kirill Lepskiy
**
**	This file is part of the ACF-Solutions Toolkit.
**
**	This file may be used under the terms of the GNU Lesser
**	General Public License version 2.1 as published by the Free Software
**	Foundation and appearing in the file LicenseLGPL.txt included in the
**	packaging of this file.  Please review the following information to
**	ensure the GNU Lesser General Public License version 2.1 requirements
**	will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
**	If you are unsure which license is appropriate for your use, please
**	contact us at info@imagingtools.de.
**
** 	See http://www.imagingtools.de, write info@imagingtools.de or contact
**	by Skype to ACF_infoline for further information about the ACF-Solutions.
**
********************************************************************************/


#include "isig/CTriggerParamsComp.h"


#include "istd/TChangeNotifier.h"

#include "iser/IArchive.h"
#include "iser/CArchiveTag.h"


namespace isig
{


CTriggerParamsComp::CTriggerParamsComp()
:	m_triggerMode(TM_NONE)
{
}


// reimplemented (isig::ITriggerParams)

const ITriggerConstraints* CTriggerParamsComp::GetTriggerConstraints() const
{
	return m_triggerConstraintsCompPtr.GetPtr();
}


int CTriggerParamsComp::GetTriggerMode() const
{
	return m_triggerMode;
}


void CTriggerParamsComp::SetTriggerMode(int triggerMode)
{
	if (m_triggerMode!= triggerMode){
		istd::CChangeNotifier changePtr(this);

		m_triggerMode = triggerMode;
	}
}


// reimplemented (iprm::ISelectionParam)

const iprm::ISelectionConstraints* CTriggerParamsComp::GetSelectionConstraints() const
{
	return this;
}


int CTriggerParamsComp::GetSelectedOptionIndex() const
{
	I_ASSERT(m_triggerMode >= 0);

	int optionsCount = int(m_selectionList.size());
	for (int i = 0; i < optionsCount; ++i){
		const SelectionEntry& entry = m_selectionList[i];
		if (entry.triggerMode == m_triggerMode){
			return i;
		}
	}

	return -1;
}


bool CTriggerParamsComp::SetSelectedOptionIndex(int index)
{
	if (index >= 0){
		SetTriggerMode(m_selectionList[index].triggerMode);

		return true;
	}
	else{
		return false;
	}
}


iprm::ISelectionParam* CTriggerParamsComp::GetActiveSubselection() const
{
	return NULL;
}


// reimplemented (iser::ISerializable)

bool CTriggerParamsComp::Serialize(iser::IArchive& archive)
{
	bool retVal = true;

	static iser::CArchiveTag bottomTag("TriggerMode", "Trigger mode");
	retVal = retVal && archive.BeginTag(bottomTag);
	retVal = retVal && archive.Process(m_triggerMode);
	retVal = retVal && archive.EndTag(bottomTag);

	return retVal;
}


// protected methods

void CTriggerParamsComp::InitializeSelectionList()
{
	m_selectionList.clear();
	if (!m_triggerConstraintsCompPtr.IsValid() || m_triggerConstraintsCompPtr->IsTriggerModeSupported(TM_NONE)){
		SelectionEntry entry = {"None", "No trigger input", TM_NONE};
		m_selectionList.push_back(entry);
	}
	if (!m_triggerConstraintsCompPtr.IsValid() || m_triggerConstraintsCompPtr->IsTriggerModeSupported(TM_CONTINUOUS)){
		SelectionEntry entry = {"Continuous", "Continuous mode", TM_CONTINUOUS};
		m_selectionList.push_back(entry);
	}
	if (!m_triggerConstraintsCompPtr.IsValid() || m_triggerConstraintsCompPtr->IsTriggerModeSupported(TM_RISING_EDGE)){
		SelectionEntry entry = {"Rising edge", "Rising trigger edge", TM_RISING_EDGE};
		m_selectionList.push_back(entry);
	}
	if (!m_triggerConstraintsCompPtr.IsValid() || m_triggerConstraintsCompPtr->IsTriggerModeSupported(TM_FALLING_EDGE)){
		SelectionEntry entry = {"Falling edge", "Falling trigger edge", TM_FALLING_EDGE};
		m_selectionList.push_back(entry);
	}
	if (!m_triggerConstraintsCompPtr.IsValid() || m_triggerConstraintsCompPtr->IsTriggerModeSupported(TM_POSITIVE_LEVEL)){
		SelectionEntry entry = {"Positive level", "Positive level", TM_POSITIVE_LEVEL};
		m_selectionList.push_back(entry);
	}
	if (!m_triggerConstraintsCompPtr.IsValid() || m_triggerConstraintsCompPtr->IsTriggerModeSupported(TM_NEGATIVE_LEVEL)){
		SelectionEntry entry = {"Negative level", "Negative level", TM_NEGATIVE_LEVEL};
		m_selectionList.push_back(entry);
	}
	if (!m_triggerConstraintsCompPtr.IsValid() || m_triggerConstraintsCompPtr->IsTriggerModeSupported(TM_SOFTWARE)){
		SelectionEntry entry = {"Software", "Software trigger", TM_SOFTWARE};
		m_selectionList.push_back(entry);
	}
}


// reimplemented (iprm::ISelectionConstraints)

int CTriggerParamsComp::GetConstraintsFlags() const
{
	return SCF_SUPPORT_UNIQUE_ID;
}


int CTriggerParamsComp::GetOptionsCount() const
{
	return int(m_selectionList.size());
}


istd::CString CTriggerParamsComp::GetOptionName(int index) const
{
	I_ASSERT(int(m_selectionList.size()) > index);
	I_ASSERT(index >= 0);

	return m_selectionList[index].name;
}


istd::CString CTriggerParamsComp::GetOptionDescription(int index) const
{
	I_ASSERT(int(m_selectionList.size()) > index);
	I_ASSERT(index >= 0);

	return m_selectionList[index].description;
}


std::string CTriggerParamsComp::GetOptionId(int index) const
{
	I_ASSERT(int(m_selectionList.size()) > index);
	I_ASSERT(index >= 0);

	return m_selectionList[index].name.ToString();
}


// reimplemented (icomp::CComponentBase)

void CTriggerParamsComp::OnComponentCreated()
{
	BaseClass::OnComponentCreated();

	m_triggerMode = *m_triggerModeAttrPtr;

	InitializeSelectionList();
}


} // namespace isig


