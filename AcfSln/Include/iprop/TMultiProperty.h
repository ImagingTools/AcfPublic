/********************************************************************************
**
**	Copyright (c) 2007-2014 Witold Gantzke & Kirill Lepskiy
**
**	This file is part of the ACF-Solutions Toolkit.
**
**	This file may be used under the terms of the GNU Lesser
**	General Public License version 2.1 as published by the Free Software
**	Foundation and appearing in the file LicenseLGPL.txt included in the
**	packaging of this file.  Please review the following information to
**	ensure the GNU Lesser General Public License version 2.1 requirements
**	will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
**	If you are unsure which license is appropriate for your use, please
**	contact us at info@imagingtools.de.
**
** 	See http://www.ilena.org, write info@imagingtools.de or contact
**	by Skype to ACF_infoline for further information about the ACF-Solutions.
**
********************************************************************************/


#ifndef iprop_TMultiProperty_included
#define iprop_TMultiProperty_included


// Qt includes
#include <QtCore/QVector>
#include <QtCore/QStringList>


// ACF includes
#include "istd/CChangeNotifier.h"
#include "istd/CClassInfo.h"
#include "iser/IArchive.h"
#include "iser/IObject.h"
#include "iser/CArchiveTag.h"

// ACF-Solutions includes
#include "iprop/CPropertyBase.h"


namespace iprop
{


/**
	Template implementation of multiple property.
	\internal
*/
template <typename Value, class Container = QVector<Value> >
class TMultiProperty: public CPropertyBase
{
public:
	typedef Value ValueType;
	typedef CPropertyBase BaseClass;
	typedef Container ValueList;
	typedef typename ValueList::iterator iterator;
	typedef typename ValueList::const_iterator const_iterator;

	/**
		Default constructor.
	*/
	TMultiProperty();

	/**
		Constructor.
		\param	propertyOwnerPtr	Owner of the property.
		\param	propertyId		Unique ID of the property.
		\param	propertyId		Property description.
		\param	changeFlags		Change flags for model update notification.
		\param	elementsCount	Number of elements stored at \c valuesPtr.
		\param	valuesPtr		Pointer to array of elements.
	*/
	TMultiProperty(
				IPropertiesManager* propertyOwnerPtr,
				const QByteArray& propertyId,
				const QByteArray& propertyDescription,
				int propertyFlags,
				int changeFlags = 0,
				int elementsCount = 0,
				Value* valuesPtr = NULL);

	void SetValues(const ValueList& valueList);

	/**
		Set value list to the property.
	*/
	template <class ContainerImpl>
	void SetValues(typename ContainerImpl::const_iterator begin, typename ContainerImpl::const_iterator end);

	/**
		Get all values.
	*/
	const ValueList& GetValues() const;

	/**
		Get number of values in the multi property.
	*/
	virtual int GetValuesCount() const;

	/**
		Get value at the index \c index
	*/
	virtual Value GetValueAt(int index) const;

	/**
		Set value at the index \c index to new value \c value.
	*/
	virtual void SetValueAt(int index, const Value& value);

	/**
		Insert new value into container.
	*/
	virtual void InsertValue(const Value& value);

	/**
		Remove all values from the container.
	*/
	virtual void ResetValues();

	// STL compatibility
	iterator begin();
	const_iterator begin() const;
	iterator end();
	const_iterator end() const;

	// reimplemented (iser::IObject)
	QByteArray GetFactoryId() const;

	// reimplemented (iser::ISerializable)
	virtual bool Serialize(iser::IArchive& archive);

	// static methods
	static QByteArray GetTypeName();

protected:
	Container m_values;
};


// public methods

template <typename Value, class Container>
TMultiProperty<Value, Container>::TMultiProperty()
{
}


template <typename Value, class Container>
TMultiProperty<Value, Container>::TMultiProperty(
			IPropertiesManager* propertyOwnerPtr,
			const QByteArray& propertyId,
			const QByteArray& propertyDescription,
			int propertyFlags,
			int changeFlags,
			int elementsCount,
			Value* valuesPtr)
	:BaseClass(propertyOwnerPtr, propertyId, propertyDescription, propertyFlags, changeFlags)
{
	for (int i = 0; i < elementsCount; ++i){
		m_values.push_back(valuesPtr[i]);
	}
}


template <typename Value, class Container>
void TMultiProperty<Value, Container>::SetValues(const ValueList& valueList)
{
	SetValues<ValueList>(valueList.begin(), valueList.end());
}


template <typename Value, class Container>
template <class ContainerImpl>
void TMultiProperty<Value, Container>::SetValues(typename ContainerImpl::const_iterator beginIter, typename ContainerImpl::const_iterator endIter)
{
	istd::IChangeable::ChangeSet changeSet;
	if (m_changeFlag != 0){
		changeSet += m_changeFlag;
	}
	istd::CChangeNotifier notifier(m_propertyOwnerPtr, changeSet);

	ResetValues();

	while (beginIter != endIter){
		InsertValue(*beginIter);

		++beginIter;
	}
}


template <typename Value, class Container>
const typename TMultiProperty<Value, Container>::ValueList& TMultiProperty<Value, Container>::GetValues() const
{
	return m_values;
}


template <typename Value, class Container>
int TMultiProperty<Value, Container>::GetValuesCount() const
{
	return int(m_values.size());
}


template <typename Value, class Container>
Value TMultiProperty<Value, Container>::GetValueAt(int index) const
{
	Q_ASSERT(index >= 0);
	Q_ASSERT(index < GetValuesCount());

	return m_values[index];
}


template <typename Value, class Container>
void TMultiProperty<Value, Container>::SetValueAt(int index, const Value& value)
{
	Q_ASSERT(index >= 0);
	Q_ASSERT(index < GetValuesCount());

	if (m_values[index] != value){
		istd::IChangeable::ChangeSet changeSet;
		if (m_changeFlag != 0){
			changeSet += m_changeFlag;
		}
		istd::CChangeNotifier notifier(m_propertyOwnerPtr, changeSet);

		m_values[index] = value;
	}
}


template <typename Value, class Container>
void TMultiProperty<Value, Container>::InsertValue(const Value& value)
{
	m_values.push_back(value);
}


template <typename Value, class Container>
void TMultiProperty<Value, Container>::ResetValues()
{
	istd::IChangeable::ChangeSet changeSet;
	if (m_changeFlag != 0){
		changeSet += m_changeFlag;
	}
	istd::CChangeNotifier notifier(m_propertyOwnerPtr, changeSet);

	m_values.clear();
}


// STL compatibility

template <typename Value, class Container>
typename TMultiProperty<Value, Container>::iterator TMultiProperty<Value, Container>::begin()
{
	return m_values.begin();
}


template <typename Value, class Container>
typename TMultiProperty<Value, Container>::const_iterator TMultiProperty<Value, Container>::begin() const
{
	return m_values.begin();
}


template <typename Value, class Container>
typename TMultiProperty<Value, Container>::iterator TMultiProperty<Value, Container>::end()
{
	return m_values.end();
}


template <typename Value, class Container>
typename TMultiProperty<Value, Container>::const_iterator TMultiProperty<Value, Container>::end() const
{
	return m_values.end();
}


// reimplemented (iser::IObject)

template <typename Value, class Container>
QByteArray TMultiProperty<Value, Container>::GetFactoryId() const
{
	return GetTypeName();
}


// reimplemented (iser::ISerializable)

template <typename Value, class Container>
bool TMultiProperty<Value, Container>::Serialize(iser::IArchive& archive)
{
	static iser::CArchiveTag valuesTag("Values", "List of property values");
	static iser::CArchiveTag valueTag("Value", "Single Value");

	bool isStoring = archive.IsStoring();

	istd::CChangeNotifier notifier(isStoring? NULL: this);

	bool retVal = true;

	if (isStoring){
		int valuesCount = int(m_values.size());

		retVal = retVal && archive.BeginMultiTag(valuesTag, valueTag, valuesCount);
		for (typename ValueList::iterator iter = m_values.begin(); iter != m_values.end(); ++iter){
			retVal = retVal && archive.BeginTag(valueTag);
			retVal = retVal && archive.Process(*iter);
			retVal = retVal && archive.EndTag(valueTag);
		}
		retVal = retVal && archive.EndTag(valuesTag);
	}
	else{
		int valuesCount = 0;

		retVal = retVal && archive.BeginMultiTag(valuesTag, valueTag, valuesCount);
		if (!retVal){
			return false;
		}

		// load properties 'in place', without allocation of new elements
		int itemIndex = 0;
		for (typename ValueList::iterator iter = m_values.begin(); iter != m_values.end(); ++iter){
			// remove rest of elements, if current number of elements is bigger than the stored
			if (itemIndex >= valuesCount){
				m_values.erase(iter, m_values.end());

				break;
			}

			retVal = retVal && archive.BeginTag(valueTag);
			retVal = retVal && archive.Process(*iter);
			retVal = retVal && archive.EndTag(valueTag);

			++itemIndex;
		}

		// load rest of properties if current number of elements is smaller than the stored
		while (itemIndex < valuesCount){
			retVal = retVal && archive.BeginTag(valueTag);
			Value value;
			retVal = retVal && archive.Process(value);
			m_values.push_back(value);
			retVal = retVal && archive.EndTag(valueTag);

			++itemIndex;
		}

		retVal = retVal && archive.EndTag(valuesTag);
	}

	return retVal;
}


// static methods

template <typename Value, class Container>
QByteArray TMultiProperty<Value, Container>::GetTypeName()
{
	return istd::CClassInfo::GetName<TMultiProperty<Value> >();
}


template <>
inline QByteArray TMultiProperty<int>::GetTypeName()
{
	return "Integer[]";
}


template <>
inline QByteArray TMultiProperty<double>::GetTypeName()
{
	return "Real[]";
}


template <>
inline QByteArray TMultiProperty<bool>::GetTypeName()
{
	return "Boolean[]";
}


template <>
inline QByteArray TMultiProperty<QString>::GetTypeName()
{
	return "String[]";
}


template <>
inline QByteArray TMultiProperty<QByteArray>::GetTypeName()
{
	return "Id[]";
}


// typedefs

typedef TMultiProperty<double> CMultiDoubleProperty;
typedef TMultiProperty<bool> CMultiBoolProperty;
typedef TMultiProperty<int> CMultiIntProperty;
typedef TMultiProperty<QString, QStringList> CMultiStringProperty;
typedef TMultiProperty<QByteArray> CMultiStdStringProperty;


} // namespace iprop


#endif // !iprop_TMultiProperty_included


