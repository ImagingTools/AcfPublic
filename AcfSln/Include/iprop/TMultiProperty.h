/********************************************************************************
**
**	Copyright (c) 2007-2011 Witold Gantzke & Kirill Lepskiy
**
**	This file is part of the ACF-Solutions Toolkit.
**
**	This file may be used under the terms of the GNU Lesser
**	General Public License version 2.1 as published by the Free Software
**	Foundation and appearing in the file LicenseLGPL.txt included in the
**	packaging of this file.  Please review the following information to
**	ensure the GNU Lesser General Public License version 2.1 requirements
**	will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
**	If you are unsure which license is appropriate for your use, please
**	contact us at info@imagingtools.de.
**
** 	See http://www.imagingtools.de, write info@imagingtools.de or contact
**	by Skype to ACF_infoline for further information about the ACF-Solutions.
**
********************************************************************************/


#ifndef iprop_TMultiProperty_included
#define iprop_TMultiProperty_included


// STL includes
#include <vector>


// Qt includes
#include <QtCore/QStringList>


// ACF includes
#include "istd/TChangeNotifier.h"
#include "istd/CClassInfo.h"

#include "iser/IArchive.h"
#include "iser/IObject.h"
#include "iser/CArchiveTag.h"

#include "iprop/CPropertyBase.h"


namespace iprop
{


/**
	Template implementation of multiple property.
	\internal
*/
template <typename Value, class Container = std::vector<Value> >
class TMultiProperty: public CPropertyBase
{
public:
	typedef Value ValueType;
	typedef CPropertyBase BaseClass;
	typedef Container ValueList;
	typedef typename ValueList::iterator iterator;
	typedef typename ValueList::const_iterator const_iterator;

	/**
		Default constructor.
	*/
	TMultiProperty();

	/**
		Constructor.
		\param	propertyOwnerPtr	Owner of the attrbiute.
		\param	propertyId		Unique ID of the attrbiute.
		\param	propertyId		Property description.
		\param	changeFlags		Change flags for model update notification.
		\param	elementsCount	Number of elements stored at \c valuesPtr.
		\param	valuesPtr		Pointer to array of elements.
	*/
	TMultiProperty(
				IPropertiesManager* propertyOwnerPtr,
				const std::string& propertyId,
				const std::string& propertyDescription,
				int propertyFlags,
				int changeFlags = 0,
				int elementsCount = 0,
				Value* valuesPtr = NULL);

	void SetValues(const ValueList& valueList);

	/**
		Set value list to the property.
	*/
	template <class ContainerImpl>
	void SetValues(typename ContainerImpl::const_iterator begin, typename ContainerImpl::const_iterator end);

	/**
		Get all values.
	*/
	const ValueList& GetValues() const;

	/**
		Get number of values in the multi property.
	*/
	virtual int GetValuesCount() const;

	/**
		Get value at the index \c index
	*/
	virtual Value GetValueAt(int index) const;

	/**
		Set value at the index \c index to new value \c value.
	*/
	virtual void SetValueAt(int index, const Value& value);

	/**
		Insert new value into container.
	*/
	virtual void InsertValue(const Value& value);

	/**
		Remove all values from the container.
	*/
	virtual void ResetValues();

	// STL compatibility
	iterator begin();
	const_iterator begin() const;
	iterator end();
	const_iterator end() const;

	// reimplemented (iser::IObject)
	std::string GetFactoryId() const;

	// reimplemented (iser::ISerializable)
	virtual bool Serialize(iser::IArchive& archive);

	// static methods
	static const std::string& GetTypeName();

protected:
	Container m_values;

private:
	static const std::string s_typeName;
};


// public methods

template <typename Value, class Container>
TMultiProperty<Value, Container>::TMultiProperty()
{
}


template <typename Value, class Container>
TMultiProperty<Value, Container>::TMultiProperty(
				IPropertiesManager* propertyOwnerPtr,
				const std::string& propertyId,
				const std::string& propertyDescription,
				int propertyFlags,
				int changeFlags,
				int elementsCount,
				Value* valuesPtr)
	:BaseClass(propertyOwnerPtr, propertyId, propertyDescription, propertyFlags, changeFlags)
{
	for (int i = 0; i < elementsCount; ++i){
		m_values.push_back(valuesPtr[i]);
	}
}


template <typename Value, class Container>
void TMultiProperty<Value, Container>::SetValues(const ValueList& valueList)
{
	SetValues<ValueList>(valueList.begin(), valueList.end());
}


template <typename Value, class Container>
template <class ContainerImpl>
void TMultiProperty<Value, Container>::SetValues(typename ContainerImpl::const_iterator beginIter, typename ContainerImpl::const_iterator endIter)
{
	istd::CChangeNotifier changePtr(m_propertyOwnerPtr, m_changeFlags);

	ResetValues();

	while (beginIter != endIter){
		InsertValue(*beginIter);

		++beginIter;
	}
}


template <typename Value, class Container>
const typename TMultiProperty<Value, Container>::ValueList& TMultiProperty<Value, Container>::GetValues() const
{
	return m_values;
}


template <typename Value, class Container>
int TMultiProperty<Value, Container>::GetValuesCount() const
{
	return int(m_values.size());
}


template <typename Value, class Container>
Value TMultiProperty<Value, Container>::GetValueAt(int index) const
{
	I_ASSERT(index >= 0);
	I_ASSERT(index < GetValuesCount());

	return m_values[index];
}


template <typename Value, class Container>
void TMultiProperty<Value, Container>::SetValueAt(int index, const Value& value)
{
	I_ASSERT(index >= 0);
	I_ASSERT(index < GetValuesCount());

	if (m_values[index] != value){
		istd::CChangeNotifier changePtr(m_propertyOwnerPtr, m_changeFlags);

		m_values[index] = value;
	}
}


template <typename Value, class Container>
void TMultiProperty<Value, Container>::InsertValue(const Value& value)
{
	m_values.push_back(value);
}


template <typename Value, class Container>
void TMultiProperty<Value, Container>::ResetValues()
{
	istd::CChangeNotifier changePtr(m_propertyOwnerPtr, m_changeFlags);
	
	m_values.clear();
}


// STL compatibility

template <typename Value, class Container>
typename TMultiProperty<Value, Container>::iterator TMultiProperty<Value, Container>::begin()
{
	return m_values.begin();
}


template <typename Value, class Container>
typename TMultiProperty<Value, Container>::const_iterator TMultiProperty<Value, Container>::begin() const
{
	return m_values.begin();
}


template <typename Value, class Container>
typename TMultiProperty<Value, Container>::iterator TMultiProperty<Value, Container>::end()
{
	return m_values.end();
}
	

template <typename Value, class Container>
typename TMultiProperty<Value, Container>::const_iterator TMultiProperty<Value, Container>::end() const
{
	return m_values.end();
}


// reimplemented (iser::IObject)

template <typename Value, class Container>
std::string TMultiProperty<Value, Container>::GetFactoryId() const
{
	return s_typeName;
}


// reimplemented (iser::ISerializable)

template <typename Value, class Container>
bool TMultiProperty<Value, Container>::Serialize(iser::IArchive& archive)
{
	bool retVal = true;

	bool isStoring = archive.IsStoring();

	static iser::CArchiveTag valuesTag("Values", "List of property values");
	static iser::CArchiveTag valueTag("Value", "Single Value");

	int valuesCount = 0;

	if (isStoring){
		valuesCount = int(m_values.size());
	}

	retVal = retVal && archive.BeginMultiTag(valuesTag, valueTag, valuesCount);

	if (!isStoring){
		if (!retVal){
			return false;
		}

		m_values.reserve(valuesCount);
	}

	for (int i = 0; i < valuesCount; ++i){
		retVal = retVal && archive.BeginTag(valueTag);
		Value value = m_values[i];
		retVal = retVal && archive.Process(value);
		m_values[i] = value;
		retVal = retVal && archive.EndTag(valueTag);
	}

	retVal = retVal && archive.EndTag(valuesTag);

	return retVal;
}


// static methods

template <typename Value, class Container>
const std::string& TMultiProperty<Value, Container>::GetTypeName()
{
	return s_typeName;
}


// private static properties

template <typename Value, class Container>
const std::string TMultiProperty<Value, Container>::s_typeName(istd::CClassInfo::GetName<TMultiProperty<Value> >());


// typedefs

typedef TMultiProperty<double> CMultiDoubleProperty;
typedef TMultiProperty<bool> CMultiBoolProperty;
typedef TMultiProperty<int> CMultiIntProperty;
typedef TMultiProperty<QString, QStringList> CMultiStringProperty;
typedef TMultiProperty<std::string> CMultiStdStringProperty;


} // namespace iprop


#endif // !iprop_TMultiProperty_included


