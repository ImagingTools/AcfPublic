/********************************************************************************
**
**	Copyright (c) 2007-2011 Witold Gantzke & Kirill Lepskiy
**
**	This file is part of the ACF-Solutions Toolkit.
**
**	This file may be used under the terms of the GNU Lesser
**	General Public License version 2.1 as published by the Free Software
**	Foundation and appearing in the file LicenseLGPL.txt included in the
**	packaging of this file.  Please review the following information to
**	ensure the GNU Lesser General Public License version 2.1 requirements
**	will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
**	If you are unsure which license is appropriate for your use, please
**	contact us at info@imagingtools.de.
**
** 	See http://www.imagingtools.de, write info@imagingtools.de or contact
**	by Skype to ACF_infoline for further information about the ACF-Solutions.
**
********************************************************************************/


#ifndef iqtinsp_TSupplierGuiCompBase_included
#define iqtinsp_TSupplierGuiCompBase_included


// Qt includes
#include <QtGui/QMessageBox>

// ACF includes
#include "istd/TChangeNotifier.h"
#include "iser/IFileLoader.h"
#include "imod/IObserver.h"
#include "iprm/IParamsSet.h"
#include "iproc/ISupplier.h"
#include "iqtgui/IGuiObject.h"
#include "iqtgui/TDesignerGuiObserverCompBase.h"
#include "iqt2d/TViewExtenderCompBase.h"

#include "iqtinsp/iqtinsp.h"


namespace iqtinsp
{


template <class UI, class WidgetType = QWidget>
class TSupplierGuiCompBase:
			public iqt2d::TViewExtenderCompBase<
						iqtgui::TDesignerGuiObserverCompBase<UI, iproc::ISupplier> >
{
public:
	typedef iqt2d::TViewExtenderCompBase<
					iqtgui::TDesignerGuiObserverCompBase<UI, iproc::ISupplier> > BaseClass;

	I_BEGIN_BASE_COMPONENT(TSupplierGuiCompBase);
		I_ASSIGN(m_paramsLoaderCompPtr, "ParamsLoader", "Loads and saves parameters from and to file", false, "ParamsLoader");
		I_ASSIGN(m_paramsSetGuiCompPtr, "ParamsSetGui", "Shows parameter set", false, "ParamsSetGui");
		I_ASSIGN(m_paramsSetObserverCompPtr, "ParamsSetGui", "Shows parameter set", false, "ParamsSetGui");
		I_ASSIGN_TO(m_paramsSetExtenderCompPtr, m_paramsSetObserverCompPtr, false);
	I_END_COMPONENT;

	TSupplierGuiCompBase();

	// reimplemented (iqt2d::IViewExtender)
	virtual void AddItemsToScene(iqt2d::IViewProvider* providerPtr, int flags);
	virtual void RemoveItemsFromScene(iqt2d::IViewProvider* providerPtr);

	// reimplemented (istd::IVisualStatusProvider)
	virtual QIcon GetStatusIcon() const;
	virtual QString GetStatusText() const;

protected:
	/**
		Check, if parameters are correct connected to GUI and can be editable.
	*/
	bool AreParamsEditable() const;

	/**
		Check if parameter loading is supported.
	*/
	bool IsLoadParamsSupported() const;

	/**
		Check if parameter storing is supported.
	*/
	bool IsSaveParamsSupported() const;

	/**
		Load parameters from external source (file).
	*/
	bool LoadParams();

	/**
		Save parameters for example to file.
	*/
	bool SaveParams();

	/**
		Do inspection test.
	*/
	bool DoTest();

	// reimplemented (iqtgui::TGuiObserverWrap)
	virtual void OnGuiModelAttached();
	virtual void OnGuiModelDetached();

	// reimplemented (iqt2d::TViewExtenderCompBase)
	virtual void CreateShapes(int sceneId, Shapes& result);

	// reimplemented (iqtgui::TGuiObserverWrap)
	virtual void UpdateGui(int updateFlags = 0);

	// abstract methods
	/**
		Get parameters widget object.
		Extern paremeters GUI will attach to this widget.
		This widget should have some layout.
	*/
	virtual QWidget* GetParamsWidget() const = 0;

private:
	I_REF(iser::IFileLoader, m_bitmapLoaderCompPtr);
	I_REF(iser::IFileLoader, m_paramsLoaderCompPtr);

	I_REF(iqtgui::IGuiObject, m_paramsSetGuiCompPtr);
	I_REF(imod::IObserver, m_paramsSetObserverCompPtr);
	I_REF(iqt2d::IViewExtender, m_paramsSetExtenderCompPtr);

	bool m_areParamsEditable;

	QIcon m_statusIcon;
	QString m_statusText;
};


// public methods

template <class UI, class WidgetType>
TSupplierGuiCompBase<UI, WidgetType>::TSupplierGuiCompBase()
:	m_areParamsEditable(false)
{
}


// reimplemented (iqt2d::IViewExtender)

template <class UI, class WidgetType>
void TSupplierGuiCompBase<UI, WidgetType>::AddItemsToScene(iqt2d::IViewProvider* providerPtr, int flags)
{
	BaseClass::AddItemsToScene(providerPtr, flags);

	if (m_paramsSetExtenderCompPtr.IsValid()){
		m_paramsSetExtenderCompPtr->AddItemsToScene(providerPtr, flags);
	}
}


template <class UI, class WidgetType>
void TSupplierGuiCompBase<UI, WidgetType>::RemoveItemsFromScene(iqt2d::IViewProvider* providerPtr)
{
	if (m_paramsSetExtenderCompPtr.IsValid()){
		m_paramsSetExtenderCompPtr->RemoveItemsFromScene(providerPtr);
	}

	BaseClass::RemoveItemsFromScene(providerPtr);
}


// reimplemented (istd::IVisualStatusProvider)

template <class UI, class WidgetType>
QIcon TSupplierGuiCompBase<UI, WidgetType>::GetStatusIcon() const
{
	return m_statusIcon;
}


template <class UI, class WidgetType>
QString TSupplierGuiCompBase<UI, WidgetType>::GetStatusText() const
{
	return m_statusText;
}


// protected methods

template <class UI, class WidgetType>
bool TSupplierGuiCompBase<UI, WidgetType>::AreParamsEditable() const
{
	return m_areParamsEditable;
}


template <class UI, class WidgetType>
bool TSupplierGuiCompBase<UI, WidgetType>::IsLoadParamsSupported() const
{
	const iproc::ISupplier* supplierPtr = BaseClass::GetObjectPtr();
	if ((supplierPtr != NULL) && m_paramsLoaderCompPtr.IsValid()){
		const iprm::IParamsSet* paramsPtr = supplierPtr->GetModelParametersSet();
		if (paramsPtr != NULL){
			if (m_paramsLoaderCompPtr->IsOperationSupported(
						paramsPtr,
						NULL,
						iser::IFileLoader::QF_LOAD | iser::IFileLoader::QF_ANONYMOUS)){
				return true;
			}
		}
	}

	return false;
}


template <class UI, class WidgetType>
bool TSupplierGuiCompBase<UI, WidgetType>::IsSaveParamsSupported() const
{
	const iproc::ISupplier* supplierPtr = BaseClass::GetObjectPtr();
	if ((supplierPtr != NULL) && m_paramsLoaderCompPtr.IsValid()){
		const iprm::IParamsSet* paramsPtr = supplierPtr->GetModelParametersSet();
		if (paramsPtr != NULL){
			if (m_paramsLoaderCompPtr->IsOperationSupported(
						paramsPtr,
						NULL,
						iser::IFileLoader::QF_SAVE | iser::IFileLoader::QF_ANONYMOUS)){
				return true;
			}
		}
	}

	return false;
}


template <class UI, class WidgetType>
bool TSupplierGuiCompBase<UI, WidgetType>::LoadParams()
{
	iproc::ISupplier* supplierPtr = BaseClass::GetObjectPtr();
	if ((supplierPtr != NULL) && m_paramsLoaderCompPtr.IsValid()){
		iprm::IParamsSet* paramsPtr = supplierPtr->GetModelParametersSet();
		if (paramsPtr != NULL){
			if (m_paramsLoaderCompPtr->LoadFromFile(*paramsPtr, "") != iser::IFileLoader::StateFailed){
				return true;
			}
			else{
				QMessageBox::information(
							NULL,
							QObject::tr("Error"),
							QObject::tr("Cannot load parameters"));
			}
		}
	}

	return false;
}


template <class UI, class WidgetType>
bool TSupplierGuiCompBase<UI, WidgetType>::SaveParams()
{
	const iproc::ISupplier* supplierPtr = BaseClass::GetObjectPtr();
	if ((supplierPtr != NULL) && m_paramsLoaderCompPtr.IsValid()){
		const iprm::IParamsSet* paramsPtr = supplierPtr->GetModelParametersSet();
		if (paramsPtr != NULL){
			if (m_paramsLoaderCompPtr->SaveToFile(*paramsPtr, "") != iser::IFileLoader::StateFailed){
				return true;
			}
			else{
				QMessageBox::information(
							NULL,
							QObject::tr("Error"),
							QObject::tr("Cannot save parameters"));
			}
		}
	}

	return false;
}


template <class UI, class WidgetType>
bool TSupplierGuiCompBase<UI, WidgetType>::DoTest()
{
	iproc::ISupplier* supplierPtr = BaseClass::GetObjectPtr();
	if (supplierPtr != NULL){
		supplierPtr->InvalidateSupplier();
		supplierPtr->EnsureWorkFinished();

		return supplierPtr->GetWorkStatus() < iproc::ISupplier::WS_ERROR;
	}

	return false;
}


// reimplemented (iqtgui::TGuiObserverWrap)

template <class UI, class WidgetType>
void TSupplierGuiCompBase<UI, WidgetType>::OnGuiModelAttached()
{
	BaseClass::OnGuiModelAttached();

	iproc::ISupplier* supplierPtr = BaseClass::GetObjectPtr();
	I_ASSERT(supplierPtr != NULL);	// model must be attached

	iprm::IParamsSet* paramsPtr = const_cast<iprm::IParamsSet*>(supplierPtr->GetModelParametersSet());
	imod::IModel* paramsModelPtr = dynamic_cast<imod::IModel*>(paramsPtr);

	m_areParamsEditable = false;
	QWidget* paramsWidget = GetParamsWidget();
	if (paramsWidget != NULL){
		if ((paramsModelPtr != NULL) && m_paramsSetGuiCompPtr.IsValid() && m_paramsSetObserverCompPtr.IsValid()){
			paramsModelPtr->AttachObserver(m_paramsSetObserverCompPtr.GetPtr());
			m_paramsSetGuiCompPtr->CreateGui(paramsWidget);

			m_areParamsEditable = true;
		}

		paramsWidget->setVisible(m_areParamsEditable);
	}
}


template <class UI, class WidgetType>
void TSupplierGuiCompBase<UI, WidgetType>::OnGuiModelDetached()
{
	iproc::ISupplier* supplierPtr = BaseClass::GetObjectPtr();
	I_ASSERT(supplierPtr != NULL);	// model must be attached

	iprm::IParamsSet* paramsPtr = const_cast<iprm::IParamsSet*>(supplierPtr->GetModelParametersSet());
	imod::IModel* paramsModelPtr = dynamic_cast<imod::IModel*>(paramsPtr);

	if (		m_paramsSetObserverCompPtr.IsValid() &&
				(paramsModelPtr != NULL) &&
				paramsModelPtr->IsAttached(m_paramsSetObserverCompPtr.GetPtr())){
		paramsModelPtr->DetachObserver(m_paramsSetObserverCompPtr.GetPtr());
	}

	if (m_paramsSetGuiCompPtr.IsValid() && m_paramsSetGuiCompPtr->IsGuiCreated()){
		m_paramsSetGuiCompPtr->DestroyGui();
	}

	m_areParamsEditable = false;

	BaseClass::OnGuiModelDetached();
}


// reimplemented (iqt2d::TViewExtenderCompBase)

template <class UI, class WidgetType>
void TSupplierGuiCompBase<UI, WidgetType>::CreateShapes(int /*sceneId*/, Shapes& /*result*/)
{
}


// reimplemented (iqtgui::TGuiObserverWrap)

template <class UI, class WidgetType>
void TSupplierGuiCompBase<UI, WidgetType>::UpdateGui(int updateFlags)
{
	BaseClass::UpdateGui(updateFlags);

	I_ASSERT(IsGuiCreated());

	istd::CChangeNotifier notfier(this);

	m_statusText = "";
	m_statusIcon = QIcon(":/Icons/StateUnknown.svg");

	QString description;

	const iproc::ISupplier* supplierPtr = GetObjectPtr();
	if (supplierPtr != NULL){
		const istd::IInformationProvider* infoProviderPtr = dynamic_cast<const istd::IInformationProvider*>(supplierPtr);

		int workStatus = supplierPtr->GetWorkStatus();

		switch (workStatus){
		case iproc::ISupplier::WS_LOCKED:
			m_statusText = tr("Locked");
			break;

		case iproc::ISupplier::WS_OK:
			if (infoProviderPtr != NULL){
				switch (infoProviderPtr->GetInformationCategory()){
				case istd::IInformationProvider::IC_WARNING:
					m_statusText = tr("Processing completed with warnings");
					m_statusIcon = QIcon(":/Icons/StateWarning.svg");
					break;

				case istd::IInformationProvider::IC_ERROR:
					m_statusText = tr("Processing completed with errors");
					m_statusIcon = QIcon(":/Icons/StateInvalid.svg");
					break;

				default:
					m_statusText = tr("Processing completed without errors");
					m_statusIcon = QIcon(":/Icons/StateOk.svg");
					break;
				}
			}
			break;

		case iproc::ISupplier::WS_CANCELED:
			m_statusText = tr("Processing canceled by user");
			break;

		case iproc::ISupplier::WS_ERROR:
			m_statusText = tr("Processing not possible");
			m_statusIcon = QIcon(":/Icons/StateInvalid.svg");
			break;

		case iproc::ISupplier::WS_CRITICAL:
			m_statusText = tr("Critical error occurred, application problem");
			m_statusIcon = QIcon(":/Icons/Error.svg");
			break;

		default:
			break;
		}
	}
}


} // namespace iqtinsp


#endif // !iqtinsp_TSupplierGuiCompBase_included


