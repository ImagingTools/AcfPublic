/********************************************************************************
**
**	Copyright (c) 2007-2011 Witold Gantzke & Kirill Lepskiy
**
**	This file is part of the ACF-Solutions Toolkit.
**
**	This file may be used under the terms of the GNU Lesser
**	General Public License version 2.1 as published by the Free Software
**	Foundation and appearing in the file LicenseLGPL.txt included in the
**	packaging of this file.  Please review the following information to
**	ensure the GNU Lesser General Public License version 2.1 requirements
**	will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
**	If you are unsure which license is appropriate for your use, please
**	contact us at info@imagingtools.de.
**
** 	See http://www.imagingtools.de, write info@imagingtools.de or contact
**	by Skype to ACF_infoline for further information about the ACF-Solutions.
**
********************************************************************************/


#include "iinsp/CInspectionTaskComp.h"


// ACF includes
#include "istd/TChangeNotifier.h"
#include "iser/IArchive.h"
#include "iser/CArchiveTag.h"


namespace iinsp
{


// reimplemented (iinsp::IInspectionTask)

int CInspectionTaskComp::GetSubtasksCount() const
{
	return m_subtasks.size();
}


iproc::ISupplier* CInspectionTaskComp::GetSubtask(int subtaskIndex) const
{
	return m_subtasks[subtaskIndex];
}


// reimplemented (iproc::ISupplier)

void CInspectionTaskComp::InvalidateSupplier()
{
	istd::CChangeNotifier notifier(this);

	int inspectionsCount = m_subtasksCompPtr.GetCount();
	for (int i = 0; i < inspectionsCount; ++i){
		iproc::ISupplier* supplierPtr = m_subtasksCompPtr[i];
		if (supplierPtr != NULL){
			supplierPtr->InvalidateSupplier();
		}
	}
}


void CInspectionTaskComp::EnsureWorkFinished()
{
	istd::CChangeNotifier notifier(this);

	int inspectionsCount = m_subtasksCompPtr.GetCount();
	for (int i = 0; i < inspectionsCount; ++i){
		iproc::ISupplier* supplierPtr = m_subtasksCompPtr[i];
		if (supplierPtr != NULL){
			supplierPtr->EnsureWorkFinished();
		}
	}
}


void CInspectionTaskComp::ClearWorkResults()
{
	istd::CChangeNotifier notifier(this);

	int inspectionsCount = m_subtasksCompPtr.GetCount();
	for (int i = 0; i < inspectionsCount; ++i){
		iproc::ISupplier* supplierPtr = m_subtasksCompPtr[i];
		if (supplierPtr != NULL){
			supplierPtr->ClearWorkResults();
		}
	}
}


int CInspectionTaskComp::GetWorkStatus() const
{
	int retVal = WS_NONE;
	int inspectionsCount = m_subtasksCompPtr.GetCount();
	for (int i = 0; i < inspectionsCount; ++i){
		const iproc::ISupplier* supplierPtr = m_subtasksCompPtr[i];
		if (supplierPtr != NULL){
			int workStatus = supplierPtr->GetWorkStatus();
			if (workStatus > retVal){
				retVal = workStatus;
			}
		}
	}

	return retVal;
}


iprm::IParamsSet* CInspectionTaskComp::GetModelParametersSet() const
{
	return &m_parameters;
}


// protected methods

// reimplemented (icomp::CComponentBase)

void CInspectionTaskComp::OnComponentCreated()
{
	BaseClass::OnComponentCreated();

	int modelsCount = m_subtaskModelsCompPtr.GetCount();
	for (int i = 0; i < modelsCount; ++i){
		imod::IModel* modelPtr = m_subtaskModelsCompPtr[i];
		if (modelPtr != NULL){
			modelPtr->AttachObserver(this);
		}
	}

	m_subtasks.clear();

	int subtasksCount = m_subtasksCompPtr.GetCount();
	for (int i = 0; i < subtasksCount; ++i){
		if (*m_reduceHierarchyAttrPtr){
			if (i < m_subtaskInspectionCompPtr.GetCount()){
				IInspectionTask* inspectionTaskPtr = m_subtaskInspectionCompPtr[i];
				if (inspectionTaskPtr != NULL){
					int childTasksCount = inspectionTaskPtr->GetSubtasksCount();
					for (int childIndex = 0; childIndex < childTasksCount; ++childIndex){
						iproc::ISupplier* taskPtr = inspectionTaskPtr->GetSubtask(childIndex);

						m_subtasks.push_back(taskPtr);
					}
					continue;
				}
			}
		}

		iproc::ISupplier* taskPtr = m_subtasksCompPtr[i];

		m_subtasks.push_back(taskPtr);
	}

	m_parameters.SetParent(this);
}


void CInspectionTaskComp::OnComponentDestroyed()
{
	m_parameters.SetParent(NULL);

	m_subtasks.clear();

	EnsureModelsDetached();

	BaseClass::OnComponentDestroyed();
}


// public methods of embedded class Parameters

CInspectionTaskComp::Parameters::Parameters()
:	m_parentPtr(NULL)
{
}


void CInspectionTaskComp::Parameters::SetParent(CInspectionTaskComp* parentPtr)
{
	if (parentPtr != m_parentPtr){
		if (m_parentPtr != NULL){
			EnsureModelsDetached();

			m_parentPtr = NULL;
		}

		if (parentPtr != NULL){
			m_parentPtr = parentPtr;

			if (m_parentPtr->m_generalParamsModelCompPtr.IsValid()){
				m_parentPtr->m_generalParamsModelCompPtr->AttachObserver(this);
			}

			int subtasksCount = m_parentPtr->m_subtasksCompPtr.GetCount();
			for (int i = 0; i < subtasksCount; ++i){
				const iproc::ISupplier* subtaskPtr = m_parentPtr->m_subtasksCompPtr[i];
				if (subtaskPtr != NULL){
					imod::IModel* modelPtr = dynamic_cast<imod::IModel*>(subtaskPtr->GetModelParametersSet());
					if (modelPtr != NULL){
						modelPtr->AttachObserver(this);
					}
				}
			}
		}
	}
}


// reimplemented (iprm::IParamsSet)

const iser::ISerializable* CInspectionTaskComp::Parameters::GetParameter(const QByteArray& id) const
{
	if (m_parentPtr != NULL){
		if (m_parentPtr->m_generalParamsCompPtr.IsValid()){
			const iser::ISerializable* paramPtr = m_parentPtr->m_generalParamsCompPtr->GetParameter(id);
			if (paramPtr != NULL){
				return paramPtr;
			}
		}

		int subtasksCount = m_parentPtr->m_subtasksCompPtr.GetCount();
		for (int i = 0; i < subtasksCount; ++i){
			const iproc::ISupplier* subtaskPtr = m_parentPtr->m_subtasksCompPtr[i];
			if (subtaskPtr != NULL){
				iprm::IParamsSet* paramsSetPtr = subtaskPtr->GetModelParametersSet();
				if (paramsSetPtr != NULL){
					const iser::ISerializable* paramPtr = paramsSetPtr->GetParameter(id);
					if (paramPtr != NULL){
						return paramPtr;
					}
				}
			}
		}
	}

	return NULL;
}


iser::ISerializable* CInspectionTaskComp::Parameters::GetEditableParameter(const QByteArray& id)
{
	if (m_parentPtr != NULL){
		if (m_parentPtr->m_generalParamsCompPtr.IsValid()){
			iser::ISerializable* paramPtr = m_parentPtr->m_generalParamsCompPtr->GetEditableParameter(id);
			if (paramPtr != NULL){
				return paramPtr;
			}
		}

		int subtasksCount = m_parentPtr->m_subtasksCompPtr.GetCount();
		for (int i = 0; i < subtasksCount; ++i){
			iproc::ISupplier* subtaskPtr = m_parentPtr->m_subtasksCompPtr[i];
			if (subtaskPtr != NULL){
				iprm::IParamsSet* paramsSetPtr = subtaskPtr->GetModelParametersSet();
				if (paramsSetPtr != NULL){
					iser::ISerializable* paramPtr = paramsSetPtr->GetEditableParameter(id);
					if (paramPtr != NULL){
						return paramPtr;
					}
				}
			}
		}
	}

	return NULL;
}


// reimplemented (iser::ISerializable)

bool CInspectionTaskComp::Parameters::Serialize(iser::IArchive& archive)
{
	bool retVal = true;

	if (m_parentPtr != NULL){
		istd::CChangeNotifier notifier(archive.IsStoring()? NULL: this);

		if (*m_parentPtr->m_serializeSuppliersAttrPtr){
			static iser::CArchiveTag taskListTag("SubtaskList", "List of inspection subtasks");
			static iser::CArchiveTag taskTag("Subtask", "Single subtask");

			int subtasksCount = m_parentPtr->m_subtasksCompPtr.GetCount();

			retVal = retVal && archive.BeginMultiTag(taskListTag, taskTag, subtasksCount);

			if (!retVal || (!archive.IsStoring() && (subtasksCount != m_parentPtr->m_subtasksCompPtr.GetCount()))){
				m_parentPtr->SendWarningMessage(MI_BAD_PARAMS_COUNT, "Bad number of parameter to serialize");
				return false;
			}

			for (int i = 0; i < subtasksCount; ++i){
				retVal = retVal && archive.BeginTag(taskTag);

				iproc::ISupplier* taskPtr = m_parentPtr->m_subtasksCompPtr[i];
				if (taskPtr == NULL){
					m_parentPtr->SendCriticalMessage(MI_NO_SUBTASK, "No subtask connected");
					return false;
				}

				iprm::IParamsSet* paramsSetPtr = taskPtr->GetModelParametersSet();
				if (paramsSetPtr != NULL){
					retVal = retVal && paramsSetPtr->Serialize(archive);
				}

				retVal = retVal && archive.EndTag(taskTag);
			}

			retVal = retVal && archive.EndTag(taskListTag);
		}

		if (m_parentPtr->m_generalParamsCompPtr.IsValid()){
			static iser::CArchiveTag generalParamsTag("GeneralParams", "General inspection parameters");

			retVal = retVal && archive.BeginTag(generalParamsTag);
			retVal = retVal && m_parentPtr->m_generalParamsCompPtr->Serialize(archive);
			retVal = retVal && archive.EndTag(generalParamsTag);
		}
	}
	else{
		retVal = false;
	}

	return retVal;
}


} // namespace iinsp


