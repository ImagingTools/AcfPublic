/********************************************************************************
**
**	Copyright (C) 2007-2017 Witold Gantzke & Kirill Lepskiy
**
**	This file is part of the ACF-Solutions Toolkit.
**
**	This file may be used under the terms of the GNU Lesser
**	General Public License version 2.1 as published by the Free Software
**	Foundation and appearing in the file LicenseLGPL.txt included in the
**	packaging of this file.  Please review the following information to
**	ensure the GNU Lesser General Public License version 2.1 requirements
**	will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
**	If you are unsure which license is appropriate for your use, please
**	contact us at info@imagingtools.de.
**
** 	See http://www.ilena.org or write info@imagingtools.de for further
** 	information about the ACF.
**
********************************************************************************/


#ifndef iinsp_CInspectionTaskComp_included
#define iinsp_CInspectionTaskComp_included


// Qt includes
#include <QtCore/QMap>

// ACF includes
#include <istd/IInformationProvider.h>
#include <istd/CChangeNotifier.h>
#include <imod/IModel.h>
#include <imod/TModelWrap.h>
#include <imod/CModelUpdateBridge.h>
#include <imod/CMultiModelObserverBase.h>
#include <ilog/CMessageContainer.h>
#include <ilog/TLoggerCompWrap.h>

// ACF-Solutions includes
#include <iinsp/IInspectionTask.h>


namespace iinsp
{


/**
	Standard component implementation of interface iinsp::IInspectionTask.
	Serializing of this object serialize all inspection parameters.
*/
class CInspectionTaskComp:
			public ilog::CLoggerComponentBase,
			virtual public IInspectionTask,
			virtual public iinsp::ISupplier,
			virtual public istd::IInformationProvider,
			protected imod::CModelUpdateBridge
{
public:
	typedef ilog::CLoggerComponentBase BaseClass;
	typedef imod::CModelUpdateBridge BaseClass2;

	enum MessageId
	{
		MI_BAD_PARAMS_COUNT = 0x5af30,
		MI_NO_SUBTASK,
		MI_LOCAL
	};

	I_BEGIN_COMPONENT(CInspectionTaskComp);
		I_REGISTER_INTERFACE(IInspectionTask);
		I_REGISTER_INTERFACE(iser::ISerializable);
		I_REGISTER_INTERFACE(iinsp::ISupplier);
		I_REGISTER_INTERFACE(istd::IInformationProvider);
		I_REGISTER_SUBELEMENT(Parameters);
		I_REGISTER_SUBELEMENT_INTERFACE_T(Parameters, iprm::IParamsSet, ExtractParameters);
		I_REGISTER_SUBELEMENT_INTERFACE_T(Parameters, iser::ISerializable, ExtractParameters);
		I_REGISTER_SUBELEMENT_INTERFACE_T(Parameters, istd::IChangeable, ExtractParameters);
		I_REGISTER_SUBELEMENT_INTERFACE_T(Parameters, imod::IModel, ExtractParameters);
		I_ASSIGN_MULTI_0(m_subtasksCompPtr, "Subtasks", "List of subtasks (suppliers)", true);
		I_ASSIGN_TO(m_subtaskModelsCompPtr, m_subtasksCompPtr, true);
		I_ASSIGN_TO(m_subtaskInspectionCompPtr, m_subtasksCompPtr, false);
		I_ASSIGN_TO(m_subtaskInfoProviderCompPtr, m_subtasksCompPtr, false);
		I_ASSIGN_MULTI_0(m_additionalSupppliersCompPtr, "AdditionalSuppliers", "Set of suppliers will be initialized and controlled together with subtasks, but they will be not listed as subtasks", false)
		I_ASSIGN(m_serializeSuppliersAttrPtr, "SerializeSuppliers", "If it is true, parameters of suppliers will be serialized", true, true);
		I_ASSIGN(m_reduceHierarchyAttrPtr, "ReduceHierarchy", "If it is true, sub inspection tasks will be rolled out", true, false);
		I_ASSIGN(m_generalParamsCompPtr, "GeneralParams", "Optional general parameter set, it will be always serialized", false, "GeneralParams");
		I_ASSIGN_TO(m_generalParamsModelCompPtr, m_generalParamsCompPtr, true);
		I_ASSIGN(m_diagnosticNameAttrPtr, "DiagnosticName", "Name of this supplier for diagnostic, if it is not set, no diagnostic log message will be send", false, "");
		I_ASSIGN(m_supportTempMessagesAttrPtr, "SupportTempMessages", "If enabled cumulation of temporary messages will be supported", true, false);
	I_END_COMPONENT;

	CInspectionTaskComp();

	// reimplemented (iinsp::IInspectionTask)
	virtual int GetSubtasksCount() const;
	virtual iinsp::ISupplier* GetSubtask(int subtaskIndex) const;
	virtual iprm::IParamsSet* GetGeneralParameters() const;

	// reimplemented (iser::ISerializable)
	virtual bool Serialize(iser::IArchive& archive);

	// reimplemented (iinsp::ISupplier)
	virtual int GetWorkStatus() const;
	virtual imod::IModel* GetWorkStatusModel() const;
	virtual void InvalidateSupplier();
	virtual void EnsureWorkInitialized();
	virtual void EnsureWorkFinished();
	virtual void ClearWorkResults();
	virtual const ilog::IMessageContainer* GetWorkMessages(int messageType) const;
	virtual iprm::IParamsSet* GetModelParametersSet() const;

	// reimplemented (istd::IInformationProvider)
	virtual QDateTime GetInformationTimeStamp() const;
	virtual InformationCategory GetInformationCategory() const;
	virtual int GetInformationId() const;
	virtual QString GetInformationDescription() const;
	virtual QString GetInformationSource() const;
	virtual int GetInformationFlags() const;

protected:
	void EnsureStatusKnown();

	// reimplemented (icomp::CComponentBase)
	virtual void OnComponentCreated();
	virtual void OnComponentDestroyed();

	// reimplemented (imod::IObserver)
	virtual void AfterUpdate(imod::IModel* modelPtr, const istd::IChangeable::ChangeSet& changeSet);

protected:
	class MessageContainer: virtual public ilog::CMessageContainer
	{
	public:
		typedef ilog::CMessageContainer BaseClass;

		MessageContainer(CInspectionTaskComp* parentPtr, iinsp::ISupplier::MessageContainerType containerType);

		// reimplemented (ilog::IMessageContainer)
		virtual int GetWorstCategory() const;
		virtual Messages GetMessages() const;
		virtual void ClearMessages();

		// reimplemented (iser::ISerializable)
		virtual bool Serialize(iser::IArchive& archive);

	private:
		CInspectionTaskComp* m_parentPtr;
		iinsp::ISupplier::MessageContainerType m_containerType;
	};

	class Parameters:
			virtual public iprm::IParamsSet,
			public imod::CModelUpdateBridge
	{
	public:
		Parameters();

		void SetParent(CInspectionTaskComp* parentPtr);

		// reimplemented (iprm::IParamsSet)
		virtual Ids GetParamIds(bool editableOnly = false) const;
		virtual const iser::ISerializable* GetParameter(const QByteArray& id) const;
		virtual iser::ISerializable* GetEditableParameter(const QByteArray& id);

		// reimplemented (iser::ISerializable)
		virtual bool Serialize(iser::IArchive& archive);

		// reimplemented (istd::IChangeable)
		virtual bool ResetData(CompatibilityMode mode = CM_WITHOUT_REFS);

	private:
		CInspectionTaskComp* m_parentPtr;
	};

	class TaskStatusObserver: public imod::CMultiModelObserverBase
	{
	public:
		typedef imod::CMultiModelObserverBase BaseClass;

		TaskStatusObserver(CInspectionTaskComp* parentPtr);

		// reimplemented (imod::IObserver)
		virtual void AfterUpdate(imod::IModel* modelPtr, const istd::IChangeable::ChangeSet& changeSet);

	private:
		CInspectionTaskComp* m_parentPtr;
	};

	class Status: virtual public istd::IChangeable
	{
	public:
		Status();

		int GetSupplierState() const;
		void SetSupplierState(int state);

	private:
		int m_state;
	};

	typedef imod::TModelWrap<Status> StatusModel;

	I_MULTIREF(iinsp::ISupplier, m_subtasksCompPtr);
	I_MULTIREF(imod::IModel, m_subtaskModelsCompPtr);
	I_MULTIREF(IInspectionTask, m_subtaskInspectionCompPtr);
	I_MULTIREF(istd::IInformationProvider, m_subtaskInfoProviderCompPtr);
	I_MULTIREF(iinsp::ISupplier, m_additionalSupppliersCompPtr);
	I_ATTR(bool, m_serializeSuppliersAttrPtr);
	I_ATTR(bool, m_reduceHierarchyAttrPtr);
	I_REF(iprm::IParamsSet, m_generalParamsCompPtr);
	I_REF(imod::IModel, m_generalParamsModelCompPtr);
	I_ATTR(QString, m_diagnosticNameAttrPtr);
	I_ATTR(bool, m_supportTempMessagesAttrPtr);

	typedef QVector<iinsp::ISupplier*> Suppliers;
	Suppliers m_subtasks;

	typedef imod::TModelWrap<Parameters> ParametersModel;
	mutable ParametersModel m_parameters;

	template <class InterfaceType>
	static InterfaceType* ExtractParameters(CInspectionTaskComp& component)
	{
		return &component.m_parameters;
	}

	bool m_isStatusKnown;

	QDateTime m_resultTypeStamp;
	InformationCategory m_resultCategory;
	QString m_resultDescription;

	MessageContainer m_resultMessages;
	MessageContainer m_tempContainer;

	istd::IChangeable::ChangeSet m_supplierResultsChangeSet;
	typedef istd::TDelPtr<istd::CChangeNotifier> NotifierPtr;

	typedef QMap<iinsp::ISupplier*, NotifierPtr> SubtaskNotifiers;
	SubtaskNotifiers m_subtaskNotifiers;

	TaskStatusObserver m_subTaskStatusObserver;

	StatusModel m_workStatus;
};


} // namespace iinsp


#endif // !iinsp_CInspectionTaskComp_included


