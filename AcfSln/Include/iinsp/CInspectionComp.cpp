/********************************************************************************
**
**	Copyright (c) 2007-2011 Witold Gantzke & Kirill Lepskiy
**
**	This file is part of the ACF-Solutions Toolkit.
**
**	This file may be used under the terms of the GNU Lesser
**	General Public License version 2.1 as published by the Free Software
**	Foundation and appearing in the file LicenseLGPL.txt included in the
**	packaging of this file.  Please review the following information to
**	ensure the GNU Lesser General Public License version 2.1 requirements
**	will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
**	If you are unsure which license is appropriate for your use, please
**	contact us at info@imagingtools.de.
**
** 	See http://www.imagingtools.de, write info@imagingtools.de or contact
**	by Skype to ACF_infoline for further information about the ACF-Solutions.
**
********************************************************************************/


#include "iinsp/CInspectionComp.h"


// ACF includes
#include "istd/TChangeNotifier.h"
#include "iser/IArchive.h"
#include "iser/CArchiveTag.h"


namespace iinsp
{


// reimplemented (iinsp::IInspection)

int CInspectionComp::GetTasksCount() const
{
	return m_inspectionsCompPtr.GetCount();
}


IInspectionTask* CInspectionComp::GetTask(int subtaskIndex) const
{
	I_ASSERT(subtaskIndex >= 0);
	I_ASSERT(subtaskIndex < m_inspectionsCompPtr.GetCount());

	return m_inspectionsCompPtr[subtaskIndex];
}


iprm::IParamsSet* CInspectionComp::GetInspectionParams() const
{
	return m_generalParamsCompPtr.GetPtr();
}


// reimplemented (iinsp::IInspectionTask)

int CInspectionComp::GetSubtasksCount() const
{
	int retVal = 0;

	int inspectionsCount = m_inspectionsCompPtr.GetCount();
	for (int i = 0; i < inspectionsCount; ++i){
		const IInspectionTask* taskPtr = m_inspectionsCompPtr[i];
		if (taskPtr != NULL){
			retVal += taskPtr->GetSubtasksCount();
		}
	}

	return retVal;
}


iproc::ISupplier* CInspectionComp::GetSubtask(int subtaskIndex) const
{
	int inspectionsCount = m_inspectionsCompPtr.GetCount();
	for (int i = 0; i < inspectionsCount; ++i){
		const IInspectionTask* taskPtr = m_inspectionsCompPtr[i];
		if (taskPtr != NULL){
			int subtasksCount = taskPtr->GetSubtasksCount();
			if (subtaskIndex < subtasksCount){
				return taskPtr->GetSubtask(subtaskIndex);
			}

			subtaskIndex -= subtasksCount;
			I_ASSERT(subtaskIndex >= 0);
		}
	}

	return NULL;
}


// reimplemented (iproc::ISupplier)

void CInspectionComp::InvalidateSupplier()
{
	istd::CChangeNotifier notifier(this);

	int inspectionsCount = m_inspectionsCompPtr.GetCount();
	for (int i = 0; i < inspectionsCount; ++i){
		iproc::ISupplier* supplierPtr = m_inspectionsCompPtr[i];
		if (supplierPtr != NULL){
			supplierPtr->InvalidateSupplier();
		}
	}

	m_isWorkFinished = false;
}


void CInspectionComp::EnsureWorkFinished()
{
	if (!m_isWorkFinished){
		{
			istd::CChangeNotifier notifier(this);

			m_workStatus = WS_NONE;
			m_timeStamp = QDateTime();
			m_informationCategory = IC_INFO;
			m_informationId = 0;
			m_informationDescription = "";
			m_informationSource = "";
			m_informationFlags = 0;

			int inspectionsCount = m_inspectionsCompPtr.GetCount();
			for (int i = 0; i < inspectionsCount; ++i){
				iproc::ISupplier* supplierPtr = m_inspectionsCompPtr[i];
				if (supplierPtr != NULL){
					supplierPtr->EnsureWorkFinished();
					int workStatus = supplierPtr->GetWorkStatus();
					if (workStatus > m_workStatus){
						m_workStatus = workStatus;
					}

					istd::IInformationProvider* infoProviderPtr = dynamic_cast<istd::IInformationProvider*>(supplierPtr);
					if (infoProviderPtr != NULL){
						InformationCategory category = infoProviderPtr->GetInformationCategory();
						if (category >= m_informationCategory){
							m_timeStamp = infoProviderPtr->GetInformationTimeStamp();
							m_informationCategory = category;
							m_informationId = infoProviderPtr->GetInformationId();
							m_informationDescription = infoProviderPtr->GetInformationDescription();
							m_informationSource = infoProviderPtr->GetInformationSource();
							m_informationFlags = infoProviderPtr->GetInformationFlags();
						}
					}
				}
			}

			if (m_timeStamp.isNull()){
				m_timeStamp = QDateTime::currentDateTime();
			}

			if (m_informationId == 0){
				m_informationId = MI_INSPECTION_DONE;
			}

			if (m_informationDescription.isEmpty()){
				m_informationDescription = QObject::tr("Inspection done");
			}
			if (m_informationSource.isEmpty()){
				m_informationSource = QObject::tr("Inspection");
			}
		}

		m_isWorkFinished = true;
	}
}


void CInspectionComp::ClearWorkResults()
{
	istd::CChangeNotifier notifier(this);

	int inspectionsCount = m_inspectionsCompPtr.GetCount();
	for (int i = 0; i < inspectionsCount; ++i){
		iproc::ISupplier* supplierPtr = m_inspectionsCompPtr[i];
		if (supplierPtr != NULL){
			supplierPtr->ClearWorkResults();
		}
	}

	m_isWorkFinished = false;
}


int CInspectionComp::GetWorkStatus() const
{
	const_cast<CInspectionComp*>(this)->EnsureWorkFinished();

	return m_workStatus;
}


iprm::IParamsSet* CInspectionComp::GetModelParametersSet() const
{
	return m_generalParamsCompPtr.GetPtr();
}


// reimplemented (iser::ISerializable)

bool CInspectionComp::Serialize(iser::IArchive& archive)
{
	bool retVal = true;

	static iser::CArchiveTag taskListTag("TaskList", "List of inspection tasks");
	static iser::CArchiveTag taskTag("Task", "Single task");

	int subtasksCount = m_inspectionsCompPtr.GetCount();

	retVal = retVal && archive.BeginMultiTag(taskListTag, taskTag, subtasksCount);

	if (!retVal || (!archive.IsStoring() && subtasksCount != m_inspectionsCompPtr.GetCount())){
		SendWarningMessage(MI_BAD_TASKS_COUNT, "Bad number of tasks to serialize");
		return false;
	}

	for (int i = 0; i < subtasksCount; ++i){
		retVal = retVal && archive.BeginTag(taskTag);

		IInspectionTask* taskPtr = m_inspectionsCompPtr[i];
		if (taskPtr == NULL){
			SendCriticalMessage(MI_NO_TASK, "No task connected");
			return false;
		}

		retVal = retVal && taskPtr->Serialize(archive);

		retVal = retVal && archive.EndTag(taskTag);
	}

	retVal = retVal && archive.EndTag(taskListTag);

	if (m_generalParamsCompPtr.IsValid()){
		static iser::CArchiveTag generalParamsTag("GeneralParams", "General inspection parameters");

		retVal = retVal && archive.BeginTag(generalParamsTag);
		retVal = retVal && m_generalParamsCompPtr->Serialize(archive);
		retVal = retVal && archive.EndTag(generalParamsTag);
	}

	return retVal;
}


// reimplemented (istd::IInformationProvider)

QDateTime CInspectionComp::GetInformationTimeStamp() const
{
	return m_timeStamp;
}


istd::IInformationProvider::InformationCategory CInspectionComp::GetInformationCategory() const
{
	return m_informationCategory;
}


int CInspectionComp::GetInformationId() const
{
	return m_informationId;
}


QString CInspectionComp::GetInformationDescription() const
{
	return m_informationDescription;
}


QString CInspectionComp::GetInformationSource() const
{
	return m_informationSource;
}


int CInspectionComp::GetInformationFlags() const
{
	return m_informationFlags;
}


// protected methods

// reimplemented (icomp::CComponentBase)

void CInspectionComp::OnComponentCreated()
{
	BaseClass::OnComponentCreated();

	int modelsCount = m_inspectionModelsCompPtr.GetCount();

	for (int i = 0; i < modelsCount; ++i){
		imod::IModel* modelPtr = m_inspectionModelsCompPtr[i];
		if (modelPtr != NULL){
			modelPtr->AttachObserver(this);
		}
	}
}


void CInspectionComp::OnComponentDestroyed()
{
	int modelsCount = m_inspectionModelsCompPtr.GetCount();

	for (int i = 0; i < modelsCount; ++i){
		imod::IModel* modelPtr = m_inspectionModelsCompPtr[i];
		if ((modelPtr != NULL) && modelPtr->IsAttached(this)){
			modelPtr->DetachObserver(this);
		}
	}

	BaseClass::OnComponentDestroyed();
}


} // namespace iinsp


