/********************************************************************************
**
**	Copyright (C) 2007-2015 Witold Gantzke & Kirill Lepskiy
**
**	This file is part of the ACF-Solutions Toolkit.
**
**	This file may be used under the terms of the GNU Lesser
**	General Public License version 2.1 as published by the Free Software
**	Foundation and appearing in the file LicenseLGPL.txt included in the
**	packaging of this file.  Please review the following information to
**	ensure the GNU Lesser General Public License version 2.1 requirements
**	will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
**	If you are unsure which license is appropriate for your use, please
**	contact us at info@imagingtools.de.
**
** 	See http://www.ilena.org or write info@imagingtools.de for further
** 	information about the ACF.
**
********************************************************************************/


#include "iqtmeas/CNumericValueWidget.h"


// Qt includes
#include <QtCore/qmath.h>


namespace iqtmeas
{


CNumericValueWidget::CNumericValueWidget(
			QWidget* parentPtr,
			bool showSlilder,
			bool showButtons,
			int inputPolicy)
:	QWidget(parentPtr),
	m_unitMultiplicationFactor(1),
	m_unitPrecisionFactor(100)
{
	m_ignoreEvents = false;

	setupUi(this);

	ValueSlider->setVisible(showSlilder);
	MinButton->setVisible(showSlilder && showButtons);
	MaxButton->setVisible(showSlilder && showButtons);

	switch (inputPolicy){
		case 2:
			ValueSB->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Fixed);
			DescriptionLabel->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Fixed);
			break;

		case 1:
			ValueSB->setSizePolicy(QSizePolicy::MinimumExpanding, QSizePolicy::Fixed);
			break;

		default:
			ValueSB->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Fixed);
			break;
	}
}


void CNumericValueWidget::SetUnitInfo(const QString& description, const imath::IUnitInfo* unitInfoPtr)
{
	DescriptionLabel->setVisible(!description.isEmpty());
	DescriptionLabel->setText(description);

	QString unitName;
	m_unitMultiplicationFactor = 1;
	int precision = 2;
	istd::CRange valueRange(0, 100);
	
	if (unitInfoPtr != NULL){
		unitName = unitInfoPtr->GetUnitName();
		m_unitMultiplicationFactor = unitInfoPtr->GetDisplayMultiplicationFactor();
		precision = unitInfoPtr->GetValueManip().GetPrecision();

		istd::CRange range = unitInfoPtr->GetValueRange();
		if (range.IsValid()){
			valueRange = range;
		}
	}

	UnitLabel->setText(unitName);
	UnitLabel->setVisible(!unitName.isEmpty());

	m_unitPrecisionFactor = qPow(10.0, double(qMin(precision, 2)));
	int displayPrecision = qMin(2, qMax(0, precision - int(log10(m_unitMultiplicationFactor) + 0.5)));

	double minValue = valueRange.GetMinValue() * m_unitMultiplicationFactor;
	double maxValue = valueRange.GetMaxValue() * m_unitMultiplicationFactor;

	ValueSB->setDecimals(displayPrecision);
	ValueSB->setRange(minValue, maxValue);
	ValueSlider->setRange(valueRange.GetMinValue() * m_unitPrecisionFactor, valueRange.GetMaxValue() * m_unitPrecisionFactor);
	MinButton->setText(QString::number(minValue));
	MaxButton->setText(QString::number(maxValue));
	ValueSB->setToolTip(tr("Range: %1 - %2").arg(minValue).arg(maxValue));
}


double CNumericValueWidget::GetValue() const
{
	return ValueSB->value() / m_unitMultiplicationFactor;
}


void CNumericValueWidget::SetValue(double value)
{
	m_ignoreEvents = true;
	ValueSB->setValue(value * m_unitMultiplicationFactor);
	ValueSlider->setValue(value * m_unitPrecisionFactor);
	m_ignoreEvents = false;
}


void CNumericValueWidget::SetupValueEditor(int editPrecision, double stepValue)
{
	if (editPrecision >= 0){
		ValueSB->setDecimals(editPrecision);
	}

	ValueSB->setSingleStep(stepValue);
}


// protected slots

void CNumericValueWidget::on_ValueSB_valueChanged(double value)
{
	if (m_ignoreEvents){
		return;
	}

	m_ignoreEvents = true;
	SetValue(value / m_unitMultiplicationFactor);
	m_ignoreEvents = false;

	Q_EMIT ValueChanged();
}


void CNumericValueWidget::on_ValueSlider_valueChanged(int value)
{
	if (m_ignoreEvents){
		return;
	}

	m_ignoreEvents = true;
	SetValue(value / m_unitPrecisionFactor);
	m_ignoreEvents = false;
}


void CNumericValueWidget::on_ValueSlider_sliderReleased()
{
	Q_EMIT ValueChanged();
}


void CNumericValueWidget::on_MinButton_clicked()
{
	ValueSB->setValue(ValueSB->minimum());
	ValueSlider->setValue(ValueSlider->minimum());
}


void CNumericValueWidget::on_MaxButton_clicked()
{
	ValueSB->setValue(ValueSB->maximum());
	ValueSlider->setValue(ValueSlider->maximum());
}



} // namespace iqtmeas


