/********************************************************************************
**
**	Copyright (c) 2007-2011 Witold Gantzke & Kirill Lepskiy
**
**	This file is part of the ACF-Solutions Toolkit.
**
**	This file may be used under the terms of the GNU Lesser
**	General Public License version 2.1 as published by the Free Software
**	Foundation and appearing in the file LicenseLGPL.txt included in the
**	packaging of this file.  Please review the following information to
**	ensure the GNU Lesser General Public License version 2.1 requirements
**	will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
**	If you are unsure which license is appropriate for your use, please
**	contact us at info@imagingtools.de.
**
** 	See http://www.ilena.org, write info@imagingtools.de or contact
**	by Skype to ACF_infoline for further information about the ACF-Solutions.
**
********************************************************************************/


#include "iedge/CFastEdgesExtractorComp.h"


// STL includes
#include <cmath>

// QT includes
#include <QtCore/QVector>
#include <QtCore/qmath.h>

// ACF includes
#include "istd/TDelPtr.h"
#include "imath/CGeneralUnitInfo.h"
#include "i2d/CPolypoint.h"
#include "i2d/CVector2d.h"
#include "iprm/TParamsPtr.h"

// ACF-Solutions includes
#include "iedge/CEdgeNode.h"
#include "iedge/CEdgeLine.h"
#include "iedge/CEdgeLineContainer.h"


namespace iedge
{


//	reimplemented (iedge::IEdgesExtractor)

bool CFastEdgesExtractorComp::DoContourExtraction(
			const iprm::IParamsSet* paramsPtr,
			const iimg::IBitmap& bitmap,
			CEdgeLineContainer& result) const
{
	istd::CChangeNotifier notifier(&result);

	result.Reset();

	ibase::CSize size = bitmap.GetImageSize();
	if ((size.GetX() < 3) || (size.GetY() < 3)){
		SendErrorMessage(0, "Image too small to calculate edges");

		return false;
	}

	imath::CVarVector thresholdValues;
	if ((paramsPtr != NULL) && m_thresholdParamIdAttrPtr.IsValid()){
		iprm::TParamsPtr<imeas::INumericValue> thresholdParamPtr(paramsPtr, *m_thresholdParamIdAttrPtr);
		if (thresholdParamPtr.IsValid()){
			thresholdValues = thresholdParamPtr->GetValues();
		}
	}
	else if (m_defaultThresholdParamCompPtr.IsValid()){
		thresholdValues = m_defaultThresholdParamCompPtr->GetValues();
	}

	double threshold = (thresholdValues.GetElementsCount() > 0)? thresholdValues.GetElement(0): 0.1;
	double scaleFactor = (thresholdValues.GetElementsCount() > 1)? thresholdValues.GetElement(1): 0;
	double weightScale = qPow(10, scaleFactor * 0.1);

	iprm::TParamsPtr<i2d::IObject2d> aoiObjectPtr;
	if ((paramsPtr != NULL) && m_aoiParamIdAttrPtr.IsValid()){
		aoiObjectPtr.Init(paramsPtr, *m_aoiParamIdAttrPtr);
	}
	else if (m_defaultAoiCompPtr.IsValid()){
		aoiObjectPtr.SetPtr(m_defaultAoiCompPtr.GetPtr());
	}

	const iimg::CScanlineMask* maskPtr = NULL;

	iimg::CScanlineMask mask;
	if (aoiObjectPtr.IsValid()){
		mask.SetCalibration(bitmap.GetCalibration());

		i2d::CRect clipArea(size);
		if (mask.CreateFromGeometry(*aoiObjectPtr.GetPtr(), &clipArea)){
			maskPtr = &mask;
		}
	}

	const quint32 threshold2Factor = quint32(threshold * threshold * THRESHOLD_FACTOR * THRESHOLD_FACTOR / (weightScale * weightScale));

	int width = size.GetX();

	QVector<PixelDescriptor> destLine1(width);
	QVector<PixelDescriptor> destLine2(width);
	QVector<PixelDescriptor> destLine3(width);

	PixelDescriptor* destLine1Ptr = &destLine1[0];
	PixelDescriptor* destLine2Ptr = &destLine2[0];
	PixelDescriptor* destLine3Ptr = &destLine3[0];

	memset(destLine1Ptr, 0, width * sizeof(PixelDescriptor));
	memset(destLine2Ptr, 0, width * sizeof(PixelDescriptor));
	memset(destLine3Ptr, 0, width * sizeof(PixelDescriptor));

	InternalContainer container(*m_maxNodesCountAttrPtr);

	if (maskPtr != NULL){
		iimg::CScanlineMask resultMask = *maskPtr;
		resultMask.Intersection(resultMask.GetTranslated(1, 0));
		resultMask.Intersection(resultMask.GetTranslated(2, 0));
		resultMask.Intersection(resultMask.GetTranslated(0, 1));
		resultMask.Intersection(resultMask.GetTranslated(0, 2));

		const quint8* prevSourceLinePtr = (const quint8*)bitmap.GetLinePtr(0);
		const quint8* sourceLinePtr = (const quint8*)bitmap.GetLinePtr(1);

		istd::CIntRange imageRangeH(0, size.GetX());

		for (int y = 0; y < size.GetY(); ++y){
			sourceLinePtr = (const quint8*)bitmap.GetLinePtr(y);

			const istd::CIntRanges* inputRangesPtr = maskPtr->GetPixelRanges(y);
			if (inputRangesPtr != NULL){
				istd::CIntRanges::RangeList rangeList;
				inputRangesPtr->GetAsList(imageRangeH, rangeList);

				for (istd::CIntRanges::RangeList::ConstIterator iter = rangeList.constBegin();
							iter != rangeList.constEnd();
							++iter){
					const istd::CIntRange& rangeH = *iter;

					CalcDerivativeLine(prevSourceLinePtr, sourceLinePtr, rangeH.GetMinValue(), rangeH.GetMaxValue(), destLine3Ptr);
				}
			}

			const istd::CIntRanges* outputRangesPtr = resultMask.GetPixelRanges(y);
			if (outputRangesPtr != NULL){
				Q_ASSERT(y >= 3);

				istd::CIntRanges::RangeList rangeList;
				outputRangesPtr->GetAsList(imageRangeH, rangeList);

				for (istd::CIntRanges::RangeList::ConstIterator iter = rangeList.constBegin();
							iter != rangeList.constEnd();
							++iter){
					const istd::CIntRange& rangeH = *iter;
					Q_ASSERT(rangeH.GetMinValue() >= 3);
					Q_ASSERT(rangeH.GetMaxValue() <= size.GetX());

					CalcOutputLine(rangeH.GetMinValue(), rangeH.GetMaxValue(), y, threshold2Factor, destLine1Ptr, destLine2Ptr, destLine3Ptr, container);
				}
			}

			// move line address in rolling line buffer
			PixelDescriptor* storedDestLine1Ptr = destLine1Ptr;
			destLine1Ptr = destLine2Ptr;
			destLine2Ptr = destLine3Ptr;
			destLine3Ptr = storedDestLine1Ptr;

			prevSourceLinePtr = sourceLinePtr;
		}
	}
	else{
		const quint8* prevSourceLinePtr = (const quint8*)bitmap.GetLinePtr(0);
		const quint8* sourceLinePtr = (const quint8*)bitmap.GetLinePtr(1);
		CalcDerivativeLine(prevSourceLinePtr, sourceLinePtr, 0, width, destLine1Ptr);

		prevSourceLinePtr = sourceLinePtr;
		sourceLinePtr = (const quint8*)bitmap.GetLinePtr(2);
		CalcDerivativeLine(prevSourceLinePtr, sourceLinePtr, 0, width, destLine1Ptr);

		prevSourceLinePtr = sourceLinePtr;
		for (int y = 3; y < size.GetY(); ++y){
			sourceLinePtr = (const quint8*)bitmap.GetLinePtr(y);

			CalcDerivativeLine(prevSourceLinePtr, sourceLinePtr, 0, width, destLine3Ptr);
			CalcOutputLine(3, width, y, threshold2Factor, destLine1Ptr, destLine2Ptr, destLine3Ptr, container);

			// move line address in rolling line buffer
			PixelDescriptor* storedDestLine1Ptr = destLine1Ptr;
			destLine1Ptr = destLine2Ptr;
			destLine2Ptr = destLine3Ptr;
			destLine3Ptr = storedDestLine1Ptr;

			prevSourceLinePtr = sourceLinePtr;
		}
	}

	container.ExtractLines(weightScale, result, *m_keepSingletonsAttrPtr);

	// copy calibration from bitmap
	const i2d::ICalibration2d* bitmapCalibrationPtr = bitmap.GetCalibration();
	if (bitmapCalibrationPtr != NULL){
		istd::TDelPtr<i2d::ICalibration2d> newCalibration;
		newCalibration.SetCastedOrRemove(bitmapCalibrationPtr->CloneMe());

		result.SetCalibration(newCalibration.PopPtr(), true);
	}
	else{
		result.SetCalibration(NULL);
	}

	if (container.IsContainerFull()){
		SendErrorMessage(0, "Container of nodes is full");
	}

	return true;
}


// reimplemented (iproc::IProcessor)

int CFastEdgesExtractorComp::DoProcessing(
		const iprm::IParamsSet* paramsPtr,
		const istd::IPolymorphic* inputPtr,
		istd::IChangeable* outputPtr,
		ibase::IProgressManager* /*progressManagerPtr*/)
{
	if (outputPtr == NULL){
		return TS_OK;
	}

	const iimg::IBitmap* bitmapPtr = dynamic_cast<const iimg::IBitmap*>(inputPtr);
	CEdgeLineContainer* containerPtr = dynamic_cast<CEdgeLineContainer*>(outputPtr);

	if (		(bitmapPtr == NULL) ||
				(containerPtr == NULL)){
		return TS_INVALID;
	}

	return DoContourExtraction(paramsPtr, *bitmapPtr, *containerPtr)? TS_OK: TS_INVALID;
}


// reimplemented (imeas::INumericConstraints)

int CFastEdgesExtractorComp::GetNumericValuesCount() const
{
	return 2;
}


QString CFastEdgesExtractorComp::GetNumericValueName(int index) const
{
	switch (index){
	case 0:
		return QObject::tr("Threshold", "Contour extraction threshold");

	case 1:
		return QObject::tr("Scale", "Contour scale factor");

	default:
		return "";
	}
}


QString CFastEdgesExtractorComp::GetNumericValueDescription(int index) const
{
	switch (index){
	case 0:
		return QObject::tr("Contour extraction threshold");

	case 1:
		return QObject::tr("Contour scale factor");

	default:
		return "";
	}
}


const imath::IUnitInfo& CFastEdgesExtractorComp::GetNumericValueUnitInfo(int index) const
{
	static imath::CGeneralUnitInfo thresholdUnitInfo(imath::IUnitInfo::UT_RELATIVE, "%", 100, istd::CRange(0.01, 1));
	static imath::CGeneralUnitInfo scaleUnitInfo(imath::IUnitInfo::UT_RELATIVE, "dB", 1, istd::CRange(-10, 10));

	switch (index){
	case 0:
		return thresholdUnitInfo;

	default:
		return scaleUnitInfo;
	}
}


// private static methods

inline void CFastEdgesExtractorComp::TryConnectElements(
			PixelDescriptor& neightborPixel,
			PixelDescriptor& pixel)
{
	ExtNode* neightborNodePtr = neightborPixel.listReference;
	if (neightborNodePtr == NULL){
		return;
	}

	ExtNode* nodePtr = pixel.listReference;
	Q_ASSERT(nodePtr != NULL);

	const i2d::CVector2d& elementPosition = neightborNodePtr->position;
	i2d::CVector2d displacement = elementPosition - nodePtr->position;

	double derivativeDotProduct = nodePtr->derivative.GetDotProduct(neightborNodePtr->derivative);
	if (derivativeDotProduct > 0){
		double orientationFactor = (nodePtr->derivative + neightborNodePtr->derivative).GetCrossProductZ(displacement) / displacement.GetLength2();
		if (orientationFactor >= 0){
			double connectionWeight = orientationFactor * derivativeDotProduct * nodePtr->rawWeight * neightborNodePtr->rawWeight;
			if (			(connectionWeight > nodePtr->nextWeight) &&
							((neightborNodePtr->prevPtr == NULL) || (neightborNodePtr->prevWeight < connectionWeight))){
				// disconnect neighbor from previous connection
				if (neightborNodePtr->prevPtr != NULL){
					Q_ASSERT(neightborNodePtr->prevPtr->nextPtr == neightborNodePtr);

					neightborNodePtr->prevPtr->nextPtr = NULL;
				}

				if (nodePtr->nextPtr != NULL){
					Q_ASSERT(nodePtr->nextPtr->prevPtr == nodePtr);

					nodePtr->nextPtr->prevPtr = NULL;
				}

				// connect both nodes
				nodePtr->nextPtr = neightborNodePtr;
				nodePtr->nextWeight = connectionWeight;
				neightborNodePtr->prevPtr = nodePtr;
				neightborNodePtr->prevWeight = connectionWeight;
			}
		}
		else{
			double connectionWeight = -orientationFactor * derivativeDotProduct * nodePtr->rawWeight * neightborNodePtr->rawWeight;
			if (			(connectionWeight > nodePtr->prevWeight) &&
							((neightborNodePtr->nextPtr == NULL) || (neightborNodePtr->nextWeight < connectionWeight))){
				// disconnect neighbor from previous connection
				if (neightborNodePtr->nextPtr != NULL){
					Q_ASSERT(neightborNodePtr->nextPtr->prevPtr == neightborNodePtr);

					neightborNodePtr->nextPtr->prevPtr = NULL;
				}

				if (nodePtr->prevPtr != NULL){
					Q_ASSERT(nodePtr->prevPtr->nextPtr == nodePtr);

					nodePtr->prevPtr->nextPtr = NULL;
				}

				// connect both nodes
				nodePtr->prevPtr = neightborNodePtr;
				nodePtr->prevWeight = connectionWeight;
				neightborNodePtr->nextPtr = nodePtr;
				neightborNodePtr->nextWeight = connectionWeight;
			}
		}
	}
}


inline void CFastEdgesExtractorComp::CalcDerivative(
			const quint8* prevSourceLine,
			const quint8* sourceLine,
			int x,
			PixelDescriptor& pixelDescriptor){
	Q_ASSERT(x > 0);

	int pixel11 = prevSourceLine[x - 1];
	int pixel21 = prevSourceLine[x];
	int pixel12 = sourceLine[x - 1];
	int pixel22 = sourceLine[x];

	int dx = pixel11 + pixel12 - pixel21 - pixel22;
	int dy = pixel11 + pixel21 - pixel12 - pixel22;

	pixelDescriptor.brightness = qint16(pixel11 + pixel21 + pixel12 + pixel22);
	pixelDescriptor.dx = qint16(dx);
	pixelDescriptor.dy = qint16(dy);
	pixelDescriptor.dirLength2 = quint32(dx * dx + dy * dy);
	pixelDescriptor.listReference = NULL;
}


inline void CFastEdgesExtractorComp::CalcDerivativeLine(
			const quint8* prevSourceLine,
			const quint8* sourceLine,
			int inputBeginX,
			int inputEndX,
			PixelDescriptor* destLine){
	for (int x = inputBeginX + 1; x < inputEndX; ++x){
		PixelDescriptor& pixelDescriptor = destLine[x];

		CalcDerivative(prevSourceLine, sourceLine, x, pixelDescriptor);
	}
}


inline void CFastEdgesExtractorComp::CalcPoint(
			int x,
			int y,
			quint32 threshold2Factor,
			PixelDescriptor* prevPrevDestLine,
			PixelDescriptor* prevDestLine,
			PixelDescriptor* destLine,
			InternalContainer& container)
{
	Q_ASSERT(x >= 3);
	Q_ASSERT(y >= 3);

	PixelDescriptor& centralDescriptor = prevDestLine[x - 1];

	quint32 dirLength2 = centralDescriptor.dirLength2;

	if (dirLength2 <= threshold2Factor){
		return;	// edge to weak
	}

	const PixelDescriptor& leftDescriptor = prevDestLine[x - 2];
	const PixelDescriptor& rightDescriptor = prevDestLine[x];
	const PixelDescriptor& topDescriptor = prevPrevDestLine[x - 1];
	const PixelDescriptor& bottomDescriptor = destLine[x - 1];

	int left2Diff = dirLength2 - leftDescriptor.dirLength2;
	int right2Diff = dirLength2 - rightDescriptor.dirLength2;
	int top2Diff = dirLength2 - topDescriptor.dirLength2;
	int bottom2Diff = dirLength2 - bottomDescriptor.dirLength2;

	if (((left2Diff < 0) || (right2Diff <= 0)) && ((top2Diff < 0) || (bottom2Diff <= 0))){
		return;	// it is not local maximum
	}
	double horizStrength2 = 0;
	if ((left2Diff >= 0) && (right2Diff > 0)){
		horizStrength2 = left2Diff + right2Diff;
	}

	double vertStrength2 = 0;
	if ((top2Diff >= 0) && (bottom2Diff > 0)){
		vertStrength2 = top2Diff + bottom2Diff;
	}
/*
	if (horizStrength2 + vertStrength2 <= threshold2Factor){
		return;	// not enough strong compared to noise
	}
*/
	ExtNode* nodePtr = container.AddElementToList();
	if (nodePtr == NULL){
		return;	// edge cannot be allocated
	}

	bool isHorizontal = (horizStrength2 > vertStrength2);

	// calculate new point values
	double dirLength = qSqrt(dirLength2);
	nodePtr->derivative = i2d::CVector2d(double(centralDescriptor.dx) / THRESHOLD_FACTOR, double(centralDescriptor.dy) / THRESHOLD_FACTOR);
	nodePtr->rawWeight = qSqrt(horizStrength2 + vertStrength2);
	nodePtr->prevPtr = NULL;
	nodePtr->nextPtr = NULL;
	nodePtr->prevWeight = 0;
	nodePtr->nextWeight = 0;
	nodePtr->isHorizontal = isHorizontal;

	if (isHorizontal){
		double leftDiff = qSqrt(dirLength) - qSqrt(qSqrt(leftDescriptor.dirLength2));
		Q_ASSERT(leftDiff >= 0);
		double rightDiff = qSqrt(dirLength) - qSqrt(qSqrt(rightDescriptor.dirLength2));
		Q_ASSERT(rightDiff >= 0);

		double shift = leftDiff / (leftDiff + rightDiff);

		nodePtr->position.SetX(x - 1.5 + shift);
		nodePtr->position.SetY(y - 1);
	}
	else{
		double topDiff = qSqrt(dirLength) - qSqrt(qSqrt(topDescriptor.dirLength2));
		Q_ASSERT(topDiff >= 0);
		double bottomDiff = qSqrt(dirLength) - qSqrt(qSqrt(bottomDescriptor.dirLength2));
		Q_ASSERT(bottomDiff >= 0);

		double shift = topDiff / (topDiff + bottomDiff);

		nodePtr->position.SetX(x - 1);
		nodePtr->position.SetY(y - 1.5 + shift);
	}

	PixelDescriptor& pixelDescriptor = destLine[x - 1];
	pixelDescriptor.listReference = nodePtr;

	// try connects with all already calculated neighbours
//	TryConnectElements(prevPrevDestLine[x - 1], pixelDescriptor);

	TryConnectElements(prevDestLine[x - 2], pixelDescriptor);
	TryConnectElements(prevDestLine[x - 1], pixelDescriptor);
	TryConnectElements(prevDestLine[x], pixelDescriptor);

//	TryConnectElements(destLine[x - 3], pixelDescriptor);
	TryConnectElements(destLine[x - 2], pixelDescriptor);
}


inline void CFastEdgesExtractorComp::CalcOutputLine(
			int outputBeginX,
			int outputEndX,
			int y,
			quint32 threshold2Factor,
			PixelDescriptor* prevPrevDestLine,
			PixelDescriptor* prevDestLine,
			PixelDescriptor* destLine,
			InternalContainer& container)
{
	Q_ASSERT(outputBeginX >= 3);
	Q_ASSERT(outputBeginX <= outputEndX);

	for (int x = outputBeginX; x < outputEndX; x++){
		CalcPoint(x, y, threshold2Factor, prevPrevDestLine, prevDestLine, destLine, container);
	}
}


// inline methods of embedded class InternalContainer

inline CFastEdgesExtractorComp::ExtNode* CFastEdgesExtractorComp::InternalContainer::AddElementToList()
{
	if (m_freeIndex < m_buffer.size()){
		return &m_buffer[m_freeIndex++];
	}
	else{
		m_isContainerFull = true;

		return NULL;
	}
}


// public methods of embedded class InternalContainer

CFastEdgesExtractorComp::InternalContainer::InternalContainer(int size)
:	m_buffer(size),
	m_freeIndex(0),
	m_isContainerFull(false)
{
}


bool CFastEdgesExtractorComp::InternalContainer::IsContainerFull() const
{
	return m_isContainerFull;
}


void CFastEdgesExtractorComp::InternalContainer::ExtractLines(
			double weightScale,
			CEdgeLineContainer& result,
			bool keepSingletons)
{
	// mark all as not extracted
	for (int i = 0; i < m_freeIndex; ++i){
		ExtNode& node = m_buffer[i];
		node.isExtracted = false;
	}

	// looking for opened edges
	for (int i = 0; i < m_freeIndex; ++i){
		ExtNode& node = m_buffer[i];

		if (!node.isExtracted && (node.prevPtr == NULL)){	// check if it was not processed yet and is first node
			if (!keepSingletons && (node.nextPtr == NULL)){
				node.isExtracted = true;
				continue;	// skip singleton
			}

			CEdgeLine& resultLine = result.PushBack(CEdgeLine());
			resultLine.SetClosed(false);

			for (		const ExtNode* nodeElementPtr = &node;
						nodeElementPtr != NULL;
						nodeElementPtr = nodeElementPtr->nextPtr){
				Q_ASSERT((nodeElementPtr->nextPtr == NULL) || (nodeElementPtr->nextPtr->prevPtr == nodeElementPtr));
				Q_ASSERT((nodeElementPtr->prevPtr == NULL) || (nodeElementPtr->prevPtr->nextPtr == nodeElementPtr));

				nodeElementPtr->isExtracted = true;

				CEdgeNode node(
							nodeElementPtr->position,
							nodeElementPtr->rawWeight * weightScale / THRESHOLD_FACTOR);

				resultLine.InsertNode(node);
			}
		}
	}

	// looking for closed edges
	for (int i = 0; i < m_freeIndex; ++i){
		ExtNode& node = m_buffer[i];

		if (!node.isExtracted){	// check if it was not processed yet
			if (!keepSingletons && (node.nextPtr == node.prevPtr)){
				node.isExtracted = true;
				continue;	// skip singleton
			}

			CEdgeLine& resultLine = result.PushBack(CEdgeLine());
			resultLine.SetClosed(true);

			const ExtNode* nodeElementPtr = &node;
			do{
				Q_ASSERT(nodeElementPtr->nextPtr != NULL);
				Q_ASSERT(nodeElementPtr->prevPtr != NULL);
				Q_ASSERT(nodeElementPtr->nextPtr->prevPtr == nodeElementPtr);
				Q_ASSERT(nodeElementPtr->prevPtr->nextPtr == nodeElementPtr);

				nodeElementPtr->isExtracted = true;

				CEdgeNode node(
							nodeElementPtr->position,
							nodeElementPtr->rawWeight * weightScale / THRESHOLD_FACTOR);

				resultLine.InsertNode(node);

				nodeElementPtr = nodeElementPtr->nextPtr;
			} while (nodeElementPtr != &node);
		}
	}
}


} // namespace iedge


