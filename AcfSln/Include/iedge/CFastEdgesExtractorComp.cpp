/********************************************************************************
**
**	Copyright (c) 2007-2011 Witold Gantzke & Kirill Lepskiy
**
**	This file is part of the ACF-Solutions Toolkit.
**
**	This file may be used under the terms of the GNU Lesser
**	General Public License version 2.1 as published by the Free Software
**	Foundation and appearing in the file LicenseLGPL.txt included in the
**	packaging of this file.  Please review the following information to
**	ensure the GNU Lesser General Public License version 2.1 requirements
**	will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
**	If you are unsure which license is appropriate for your use, please
**	contact us at info@imagingtools.de.
**
** 	See http://www.imagingtools.de, write info@imagingtools.de or contact
**	by Skype to ACF_infoline for further information about the ACF-Solutions.
**
********************************************************************************/


#include "iedge/CFastEdgesExtractorComp.h"


// STL includes
#include <cmath>

// QT includes
#include <QtCore/QVector>
#include <QtCore/qmath.h>

// ACF includes
#include "i2d/CPolypoint.h"
#include "i2d/CVector2d.h"
#include "iprm/TParamsPtr.h"

// ACF-Solutions includes
#include "imeas/CGeneralUnitInfo.h"

#include "iedge/CEdgeNode.h"
#include "iedge/CEdgeLine.h"
#include "iedge/CEdgeLine.h"


namespace iedge
{


//	reimplemented (iedge::IEdgesExtractor)

bool CFastEdgesExtractorComp::DoContourExtraction(
			const iprm::IParamsSet* paramsPtr,
			const iimg::IBitmap& bitmap,
			CEdgeLine::Container& result) const
{
	result.Reset();

	ibase::CSize size = bitmap.GetImageSize();
	if ((size.GetX() < 3) || (size.GetY() < 3)){
		SendErrorMessage(0, "Image too small to calculate edges");

		return false;
	}

	imath::CVarVector thresholdValues;
	if ((paramsPtr != NULL) && m_thresholdParamIdAttrPtr.IsValid()){
		iprm::TParamsPtr<imeas::INumericValue> thresholdParamPtr(paramsPtr, *m_thresholdParamIdAttrPtr);
		if (thresholdParamPtr.IsValid()){
			thresholdValues = thresholdParamPtr->GetValues();
		}
	}
	else if (m_defaultThresholdParamCompPtr.IsValid()){
		thresholdValues = m_defaultThresholdParamCompPtr->GetValues();
	}

	double threshold = (thresholdValues.GetElementsCount() > 0)? thresholdValues.GetElement(0): 0.1;
	double scaleFactor = (thresholdValues.GetElementsCount() > 1)? thresholdValues.GetElement(1): 0;
	double weightScale = qPow(10, scaleFactor * 0.1);

	iprm::TParamsPtr<i2d::IObject2d> aoiObjectPtr;
	if ((paramsPtr != NULL) && m_aoiParamIdAttrPtr.IsValid()){
		aoiObjectPtr.Init(paramsPtr, *m_aoiParamIdAttrPtr);
	}
	else if (m_defaultAoiCompPtr.IsValid()){
		aoiObjectPtr.SetPtr(m_defaultAoiCompPtr.GetPtr());
	}

	const iimg::CScanlineMask* maskPtr = NULL;

	iimg::CScanlineMask mask;
	if (aoiObjectPtr.IsValid()){
		i2d::CRect clipArea(size);
		if (mask.CreateFromGeometry(*aoiObjectPtr.GetPtr(), &clipArea)){
			maskPtr = &mask;
		}
	}

	const quint32 threshold2Factor = quint32(threshold * threshold * THRESHOLD_FACTOR * THRESHOLD_FACTOR / (weightScale * weightScale));

	int width = size.GetX();

	const quint8* sourceLinePtr = (const quint8*)bitmap.GetLinePtr(0);
	int sourceLineDiff = bitmap.GetLinesDifference();

	QVector<PixelDescriptor> destLine1(width - 1);
	QVector<PixelDescriptor> destLine2(width - 1);
	QVector<PixelDescriptor> destLine3(width - 1);

	PixelDescriptor* destLine1Ptr = &destLine1[0];
	PixelDescriptor* destLine2Ptr = &destLine2[0];
	PixelDescriptor* destLine3Ptr = &destLine3[0];

	memset(destLine1Ptr, 0, (width - 1) * sizeof(PixelDescriptor));
	memset(destLine2Ptr, 0, (width - 1) * sizeof(PixelDescriptor));
	memset(destLine3Ptr, 0, (width - 1) * sizeof(PixelDescriptor));

	InternalContainer container(*m_maxNodesCountAttrPtr);

	if (maskPtr != NULL){
		return false;
	}
	else{
		CalcFullDerivativeLine(sourceLinePtr, sourceLinePtr + sourceLineDiff, destLine1Ptr, width);
		sourceLinePtr += sourceLineDiff;
		CalcFullDerivativeLine(sourceLinePtr, sourceLinePtr + sourceLineDiff, destLine2Ptr, width);
		sourceLinePtr += sourceLineDiff;

		for (int y = 1; y < size.GetY() - 1; ++y){
			CalcLine(sourceLinePtr, sourceLinePtr + sourceLineDiff, destLine1Ptr, destLine2Ptr, destLine3Ptr, y, width, threshold2Factor, container);

			// move line address in rolling line buffer
			PixelDescriptor* storedDestLine1Ptr = destLine1Ptr;
			destLine1Ptr = destLine2Ptr;
			destLine2Ptr = destLine3Ptr;
			destLine3Ptr = storedDestLine1Ptr;

			sourceLinePtr += sourceLineDiff;
		}
	}

	container.ExtractContours(weightScale, result);

	if (container.IsContainerFull()){
		SendErrorMessage(0, "Container of nodes is full");
	}

	return true;
}


// reimplemented (iproc::IProcessor)

int CFastEdgesExtractorComp::DoProcessing(
		const iprm::IParamsSet* paramsPtr,
		const istd::IPolymorphic* inputPtr,
		istd::IChangeable* outputPtr,
		iproc::IProgressManager* /*progressManagerPtr*/)
{
	if (outputPtr == NULL){
		return TS_OK;
	}

	const iimg::IBitmap* bitmapPtr = dynamic_cast<const iimg::IBitmap*>(inputPtr);
	CEdgeLine::Container* containerPtr = dynamic_cast<CEdgeLine::Container*>(outputPtr);

	if (		(bitmapPtr == NULL) ||
				(containerPtr == NULL)){
		return TS_INVALID;
	}

	return DoContourExtraction(paramsPtr, *bitmapPtr, *containerPtr)? TS_OK: TS_INVALID;
}


// reimplemented (imeas::INumericConstraints)

int CFastEdgesExtractorComp::GetNumericValuesCount() const
{
	return 2;
}


QString CFastEdgesExtractorComp::GetNumericValueName(int index) const
{
	switch (index){
	case 0:
		return QObject::tr("Threshold", "Contour extraction threshold");

	case 1:
		return QObject::tr("Scale", "Contour scale factor");

	default:
		return "";
	}
}


QString CFastEdgesExtractorComp::GetNumericValueDescription(int index) const
{
	switch (index){
	case 0:
		return QObject::tr("Contour extraction threshold");

	case 1:
		return QObject::tr("Contour scale factor");

	default:
		return "";
	}
}


const imeas::IUnitInfo& CFastEdgesExtractorComp::GetNumericValueUnitInfo(int index) const
{
	static imeas::CGeneralUnitInfo thresholdUnitInfo(imeas::IUnitInfo::UT_RELATIVE, "%", 100, istd::CRange(0.01, 1));
	static imeas::CGeneralUnitInfo scaleUnitInfo(imeas::IUnitInfo::UT_RELATIVE, "dB", 1, istd::CRange(-10, 10));

	switch (index){
	case 0:
		return thresholdUnitInfo;

	default:
		return scaleUnitInfo;
	}
}


// private static methods

__forceinline void CFastEdgesExtractorComp::TryConnectElements(
			PixelDescriptor& neightborPixel,
			PixelDescriptor& pixel)
{
	ExtNode* neightborNodePtr = neightborPixel.listReference;
	if (neightborNodePtr == NULL){
		return;
	}

	ExtNode* nodePtr = pixel.listReference;
	Q_ASSERT(nodePtr != NULL);

	const i2d::CVector2d& elementPosition = neightborNodePtr->position;
	i2d::CVector2d displacement = elementPosition - nodePtr->position;

	double derivativeDotProduct = nodePtr->derivative.GetDotProduct(neightborNodePtr->derivative);

	if (derivativeDotProduct > 0){
		double derivativeAngleCos = derivativeDotProduct / (nodePtr->derivative.GetLength() * neightborNodePtr->derivative.GetLength());

		double orientationFactor = (nodePtr->derivative + neightborNodePtr->derivative).GetCrossProductZ(displacement) / displacement.GetLength2();
		if (orientationFactor >= 0){
			double connectionWeight = orientationFactor * derivativeAngleCos;
			if (			(connectionWeight > nodePtr->nextWeight) &&
							((neightborNodePtr->prevPtr == NULL) || (neightborNodePtr->prevWeight < connectionWeight))){
				// disconnect neighbor from previous connection
				if (neightborNodePtr->prevPtr != NULL){
					Q_ASSERT(neightborNodePtr->prevPtr->nextPtr == neightborNodePtr);

					neightborNodePtr->prevPtr->nextPtr = NULL;
				}

				if (nodePtr->nextPtr != NULL){
					Q_ASSERT(nodePtr->nextPtr->prevPtr == nodePtr);

					nodePtr->nextPtr->prevPtr = NULL;
				}

				// connect both nodes
				nodePtr->nextPtr = neightborNodePtr;
				nodePtr->nextWeight = connectionWeight;
				neightborNodePtr->prevPtr = nodePtr;
				neightborNodePtr->prevWeight = connectionWeight;
			}
		}
		else{
			double connectionWeight = -orientationFactor * derivativeAngleCos;
			if (			(connectionWeight > nodePtr->prevWeight) &&
							((neightborNodePtr->nextPtr == NULL) || (neightborNodePtr->nextWeight < connectionWeight))){
				// disconnect neighbor from previous connection
				if (neightborNodePtr->nextPtr != NULL){
					Q_ASSERT(neightborNodePtr->nextPtr->prevPtr == neightborNodePtr);

					neightborNodePtr->nextPtr->prevPtr = NULL;
				}

				if (nodePtr->prevPtr != NULL){
					Q_ASSERT(nodePtr->prevPtr->nextPtr == nodePtr);

					nodePtr->prevPtr->nextPtr = NULL;
				}

				// connect both nodes
				nodePtr->prevPtr = neightborNodePtr;
				nodePtr->prevWeight = connectionWeight;
				neightborNodePtr->nextPtr = nodePtr;
				neightborNodePtr->nextWeight = connectionWeight;
			}
		}
	}
}


__forceinline CFastEdgesExtractorComp::ExtNode* CFastEdgesExtractorComp::AddPointToContour(
			double posX,
			double posY,
			double weight,
			PixelDescriptor* destLine1,
			PixelDescriptor* destLine2,
			int x,
			int /*y*/,
			InternalContainer& container){
	ExtNode* nodePtr = container.AddElementToList();
	if (nodePtr != NULL){
		PixelDescriptor& pixelDescriptor = destLine2[x];

		nodePtr->position = i2d::CVector2d(posX, posY);
		nodePtr->derivative = i2d::CVector2d(double(pixelDescriptor.dx) / THRESHOLD_FACTOR, double(pixelDescriptor.dy) / THRESHOLD_FACTOR);
		nodePtr->weight = weight;
		nodePtr->prevPtr = NULL;
		nodePtr->nextPtr = NULL;
		nodePtr->prevWeight = 0;
		nodePtr->nextWeight = 0;

		pixelDescriptor.listReference = nodePtr;

		// try connects with all already calculated neighbours
		TryConnectElements(destLine1[x - 1], pixelDescriptor);
		TryConnectElements(destLine1[x], pixelDescriptor);
		TryConnectElements(destLine1[x + 1], pixelDescriptor);
		TryConnectElements(destLine2[x - 1], pixelDescriptor);
	}

	return nodePtr;
}


__forceinline void CFastEdgesExtractorComp::CalcFullDerivative(
			const quint8* sourceLine1,
			const quint8* sourceLine2,
			PixelDescriptor* destLine,
			int x){
	int pixel11 = sourceLine1[x];
	int pixel21 = sourceLine1[x + 1];
	int pixel12 = sourceLine2[x];
	int pixel22 = sourceLine2[x + 1];

	int dx = pixel11 + pixel12 - pixel21 - pixel22;
	int dy = pixel11 + pixel21 - pixel12 - pixel22;

	PixelDescriptor& pixelDescr = destLine[x];

	pixelDescr.brightness = qint16(pixel11 + pixel21 + pixel12 + pixel22);
	pixelDescr.dx = qint16(dx);
	pixelDescr.dy = qint16(dy);
	pixelDescr.dirLength2 = quint32(dx * dx + dy * dy);
	pixelDescr.listReference = NULL;
}


__forceinline void CFastEdgesExtractorComp::CalcFullDerivativeLine(
			const quint8* sourceLine1,
			const quint8* sourceLine2,
			PixelDescriptor* destLine,
			int sourceWidth){
	for (int x = 0; x < sourceWidth - 1; ++x){
		CalcFullDerivative(sourceLine1, sourceLine2, destLine, x);
	}
}


__forceinline void CFastEdgesExtractorComp::CalcPoint(
			const quint8* sourceLine1,
			const quint8* sourceLine2,
			PixelDescriptor* destLine1,
			PixelDescriptor* destLine2,
			PixelDescriptor* destLine3,
			int x,
			int y,
			quint32 threshold2Factor,
			InternalContainer& container)
{
	CalcFullDerivative(sourceLine1, sourceLine2, destLine3, x + 1);	// shift 1 line

	PixelDescriptor& pixelDescriptor = destLine2[x];

	quint32 dirLength2 = pixelDescriptor.dirLength2;

	if (dirLength2 > threshold2Factor){
		const PixelDescriptor& leftDescriptor = destLine2[x - 1];
		const PixelDescriptor& rightDescriptor = destLine2[x + 1];
		const PixelDescriptor& topDescriptor = destLine1[x];
		const PixelDescriptor& bottomDescriptor = destLine3[x];

		int leftDiff = dirLength2 - leftDescriptor.dirLength2;
		int rightDiff = dirLength2 - rightDescriptor.dirLength2;
		int topDiff = dirLength2 - topDescriptor.dirLength2;
		int bottomDiff = dirLength2 - bottomDescriptor.dirLength2;

		if (((leftDiff >= 0) && (rightDiff > 0)) || ((topDiff >= 0) && (bottomDiff > 0))){
			double horizStrength = 0;
			if ((leftDiff >= 0) && (rightDiff > 0)){
				horizStrength = leftDiff + rightDiff;
			}

			double vertStrength = 0;
			if ((topDiff >= 0) && (bottomDiff > 0)){
				vertStrength = topDiff + bottomDiff;
			}

			if (horizStrength + vertStrength > threshold2Factor){
				double weight = qSqrt(horizStrength + vertStrength);
				if (horizStrength > vertStrength){
					if (qAbs(pixelDescriptor.dx) * 3 > qAbs(pixelDescriptor.dy) * 2){
						double shift = double(leftDiff) / (leftDiff + rightDiff);

						AddPointToContour(
									x + 0.5 + shift, y + 1,
									weight,
									destLine1, destLine2,
									x, y,
									container);
					}
				}
				else{
					if (qAbs(pixelDescriptor.dy) * 3 > qAbs(pixelDescriptor.dx) * 2){
						double shift = double(topDiff) / (topDiff + bottomDiff);

						AddPointToContour(
									x + 1, y + 0.5 + shift,
									weight,
									destLine1, destLine2,
									x, y,
									container);
					}
				}
			}
		}
/*		else{
			if (		(dirLength2 * 2 > leftDescriptor.dirLength2 + bottomDescriptor.dirLength2) &&
						(dirLength2 * 2 > rightDescriptor.dirLength2 + topDescriptor.dirLength2)){
				double weight = qSqrt(double(dirLength2));
				double derivative1 = weight - qSqrt((leftDescriptor.dirLength2 + bottomDescriptor.dirLength2) * 0.5);
				double derivative2 = weight - qSqrt((rightDescriptor.dirLength2 + topDescriptor.dirLength2) * 0.5);
				double shift = (derivative1 - derivative2) / (derivative1 + derivative2) * 0.5;

				AddPointToContour(
							x + 1 + shift, y + 1 - shift,
							double(pixelDescriptor.dx) / THRESHOLD_FACTOR, double(pixelDescriptor.dy) / THRESHOLD_FACTOR,
							weight / THRESHOLD_FACTOR,
							destLine1, destLine2,
							x, y,
							container);
				return;
			}
		}


		int absDirectionX = qAbs(pixelDescriptor.dx);
		int absDirectionY = qAbs(pixelDescriptor.dy);

		if ((absDirectionX * 3 >= absDirectionY * 2)){
			const PixelDescriptor& prevDescriptor = destLine2[x - 1];
			const PixelDescriptor& nextDescriptor = destLine2[x + 1];
			if (		(absDirectionX > qAbs(prevDescriptor.dx)) &&
						(absDirectionX >= qAbs(nextDescriptor.dx))){
				double weight = qSqrt(double(dirLength2));
				double derivative1 = absDirectionX - qAbs(prevDescriptor.dx);
				double derivative2 = absDirectionX - qAbs(nextDescriptor.dx);
				double shift = derivative1 / (derivative1 + derivative2);

				AddPointToContour(
							x + shift + 0.5, y + 1,
							double(pixelDescriptor.dx) / THRESHOLD_FACTOR, double(pixelDescriptor.dy) / THRESHOLD_FACTOR,
							weight / THRESHOLD_FACTOR,
							destLine1, destLine2,
							x, y,
							container);
				return;
			}
		}

		if ((absDirectionY * 3 >= absDirectionX * 2)){
			const PixelDescriptor& prevDescriptor = destLine1[x];
			const PixelDescriptor& nextDescriptor = destLine3[x];
			if (		(absDirectionY > qAbs(prevDescriptor.dy)) &&
						(absDirectionY >= qAbs(nextDescriptor.dy))){
				double weight = qSqrt(double(dirLength2));
				double derivative1 = absDirectionY - qAbs(prevDescriptor.dy);
				double derivative2 = absDirectionY - qAbs(nextDescriptor.dy);
				double shift = derivative1 / (derivative1 + derivative2);

				AddPointToContour(
							x + 1, y + shift + 0.5,
							double(pixelDescriptor.dx) / THRESHOLD_FACTOR, double(pixelDescriptor.dy) / THRESHOLD_FACTOR,
							weight / THRESHOLD_FACTOR,
							destLine1, destLine2,
							x, y,
							container);
				return;
			}
		}

		if ((absDirectionX * 3 >= absDirectionY * 2)){
			const PixelDescriptor& prevDescriptor = destLine2[x - 1];
			const PixelDescriptor& nextDescriptor = destLine2[x + 1];
			if (		(dirLength2 > prevDescriptor.dirLength2) &&
						(dirLength2 >= nextDescriptor.dirLength2)){
				double weight = qSqrt(double(dirLength2));
				double derivative1 = weight - qSqrt(double(prevDescriptor.dirLength2));
				double derivative2 = weight - qSqrt(double(nextDescriptor.dirLength2));
				double shift = derivative1 / (derivative1 + derivative2);

				AddPointToContour(
							x + shift, y + 0.5,
							double(pixelDescriptor.dx) / THRESHOLD_FACTOR, double(pixelDescriptor.dy) / THRESHOLD_FACTOR,
							weight / THRESHOLD_FACTOR,
							destLine1, destLine2,
							x, y,
							container);
				return;
			}
		}

		if ((absDirectionY * 3 >= absDirectionX * 2)){
			const PixelDescriptor& prevDescriptor = destLine1[x];
			const PixelDescriptor& nextDescriptor = destLine3[x];
			if (		(dirLength2 > prevDescriptor.dirLength2) &&
						(dirLength2 >= nextDescriptor.dirLength2)){
				double weight = qSqrt(double(dirLength2));
				double derivative1 = weight - qSqrt(double(prevDescriptor.dirLength2));
				double derivative2 = weight - qSqrt(double(nextDescriptor.dirLength2));
				double shift = derivative1 / (derivative1 + derivative2);

				AddPointToContour(
							x + 0.5, y + shift,
							double(pixelDescriptor.dx) / THRESHOLD_FACTOR, double(pixelDescriptor.dy) / THRESHOLD_FACTOR,
							weight / THRESHOLD_FACTOR,
							destLine1, destLine2,
							x, y,
							container);
				return;
			}
		}

		if (pixelDescriptor.dx * pixelDescriptor.dy > 0){
			const PixelDescriptor& prevDescriptor = destLine1[x - 1];
			const PixelDescriptor& nextDescriptor = destLine3[x + 1];

			if (		(dirLength2 > prevDescriptor.dirLength2) &&
						(dirLength2 >= nextDescriptor.dirLength2)){
				double weight = qSqrt(double(dirLength2));
				double derivative1 = weight - qSqrt(double(prevDescriptor.dirLength2));
				double derivative2 = weight - qSqrt(double(nextDescriptor.dirLength2));
				double shift = derivative1 / (derivative1 + derivative2);

				AddPointToContour(
							x + shift, y + shift,
							double(pixelDescriptor.dx) / THRESHOLD_FACTOR, double(pixelDescriptor.dy) / THRESHOLD_FACTOR,
							weight / THRESHOLD_FACTOR,
							destLine1, destLine2,
							x, y,
							container);
				return;
			}
		}
		else{
			const PixelDescriptor& prevDescriptor = destLine3[x - 1];
			const PixelDescriptor& nextDescriptor = destLine1[x + 1];

			if (		(dirLength2 > prevDescriptor.dirLength2) &&
						(dirLength2 >= nextDescriptor.dirLength2)){
				double weight = qSqrt(double(dirLength2));
				double derivative1 = weight - qSqrt(double(prevDescriptor.dirLength2));
				double derivative2 = weight - qSqrt(double(nextDescriptor.dirLength2));
				double shift = derivative1 / (derivative1 + derivative2);

				AddPointToContour(
							x + shift, y + 1 - shift,
							double(pixelDescriptor.dx) / THRESHOLD_FACTOR, double(pixelDescriptor.dy) / THRESHOLD_FACTOR,
							weight / THRESHOLD_FACTOR,
							destLine1, destLine2,
							x, y,
							container);
				return;
			}
		}
*/
	}
}


__forceinline void CFastEdgesExtractorComp::CalcLine(
			const quint8* sourceLine1,
			const quint8* sourceLine2,
			PixelDescriptor* destLine1,
			PixelDescriptor* destLine2,
			PixelDescriptor* destLine3,
			int y,
			int sourceWidth,
			quint32 threshold2Factor,
			InternalContainer& container){
	CalcFullDerivative(sourceLine1, sourceLine2, destLine3, 0);	// no shift
	CalcFullDerivative(sourceLine1, sourceLine2, destLine3, 1);	// no shift
	for (int x = 1; x < sourceWidth - 2; x++){
		CalcPoint(sourceLine1, sourceLine2, destLine1, destLine2, destLine3, x, y, threshold2Factor, container);	// no shift
	}
}


// inline methods of embedded class InternalContainer

__forceinline CFastEdgesExtractorComp::ExtNode* CFastEdgesExtractorComp::InternalContainer::AddElementToList()
{
	if (m_freeIndex < m_buffer.size()){
		return &m_buffer[m_freeIndex++];
	}
	else{
		m_isContainerFull = true;

		return NULL;
	}
}


// public methods of embedded class InternalContainer

CFastEdgesExtractorComp::InternalContainer::InternalContainer(int size)
:	m_buffer(size),
	m_freeIndex(0),
	m_isContainerFull(false)
{
}


bool CFastEdgesExtractorComp::InternalContainer::IsContainerFull() const
{
	return m_isContainerFull;
}


void CFastEdgesExtractorComp::InternalContainer::ExtractContours(double weightScale, CEdgeLine::Container& result)
{
	// mark all as not extracted
	for (int i = 0; i < m_freeIndex; ++i){
		ExtNode& node = m_buffer[i];
		node.isExtracted = false;
	}

	// looking for opened edges
	for (int i = 0; i < m_freeIndex; ++i){
		ExtNode& node = m_buffer[i];

		if (!node.isExtracted && (node.prevPtr == NULL)){	// check if it was not processed yet and is first node
			CEdgeLine& resultLine = result.PushBack(CEdgeLine());
			resultLine.SetClosed(false);

			for (		const ExtNode* nodeElementPtr = &node;
						nodeElementPtr != NULL;
						nodeElementPtr = nodeElementPtr->nextPtr){
				Q_ASSERT((nodeElementPtr->nextPtr == NULL) || (nodeElementPtr->nextPtr->prevPtr == nodeElementPtr));
				Q_ASSERT((nodeElementPtr->prevPtr == NULL) || (nodeElementPtr->prevPtr->nextPtr == nodeElementPtr));

				nodeElementPtr->isExtracted = true;

				CEdgeNode node(
							nodeElementPtr->position,
							nodeElementPtr->derivative,
							nodeElementPtr->weight * weightScale / THRESHOLD_FACTOR);

				resultLine.InsertNode(node);
			}
		}
	}

	// looking for closed edges
	for (int i = 0; i < m_freeIndex; ++i){
		ExtNode& node = m_buffer[i];

		if (!node.isExtracted){	// check if it was not processed yet
			CEdgeLine& resultLine = result.PushBack(CEdgeLine());
			resultLine.SetClosed(true);

			const ExtNode* nodeElementPtr = &node;
			do{
				Q_ASSERT(nodeElementPtr->nextPtr != NULL);
				Q_ASSERT(nodeElementPtr->prevPtr != NULL);
				Q_ASSERT(nodeElementPtr->nextPtr->prevPtr == nodeElementPtr);
				Q_ASSERT(nodeElementPtr->prevPtr->nextPtr == nodeElementPtr);

				nodeElementPtr->isExtracted = true;

				CEdgeNode node(
							nodeElementPtr->position,
							nodeElementPtr->derivative,
							nodeElementPtr->weight * weightScale / THRESHOLD_FACTOR);

				resultLine.InsertNode(node);

				nodeElementPtr = nodeElementPtr->nextPtr;
			} while (nodeElementPtr != &node);
		}
	}
}


} // namespace iedge


