/********************************************************************************
**
**	Copyright (c) 2007-2011 Witold Gantzke & Kirill Lepskiy
**
**	This file is part of the ACF-Solutions Toolkit.
**
**	This file may be used under the terms of the GNU Lesser
**	General Public License version 2.1 as published by the Free Software
**	Foundation and appearing in the file LicenseLGPL.txt included in the
**	packaging of this file.  Please review the following information to
**	ensure the GNU Lesser General Public License version 2.1 requirements
**	will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
**	If you are unsure which license is appropriate for your use, please
**	contact us at info@imagingtools.de.
**
** 	See http://www.ilena.org, write info@imagingtools.de or contact
**	by Skype to ACF_infoline for further information about the ACF-Solutions.
**
********************************************************************************/


#include "iipr/CImageHistogramProcessorComp.h"


// STL incldues
#include <cstring>

// Qt includes
#include <QtCore/qmath.h>
#include <QtCore/QCoreApplication>

// ACF includes
#include "istd/TChangeNotifier.h"
#include "ibase/CSize.h"
#include "iimg/IBitmap.h"
#include "iimg/CScanlineMask.h"


namespace iipr
{


// protected methods

// reimplemented (CImageRegionProcessorCompBase)

bool CImageHistogramProcessorComp::ProcessImageRegion(
			const iimg::IBitmap& inputBitmap,
			const iprm::IParamsSet* /*paramsPtr*/,
			const i2d::IObject2d* aoiPtr,
			istd::IChangeable* outputPtr) const
{
	imeas::IDiscreteDataSequence* histogramPtr = dynamic_cast<imeas::IDiscreteDataSequence*>(outputPtr);
	if (histogramPtr == NULL){
		return false;
	}

	if (inputBitmap.IsEmpty()){
		histogramPtr->ResetSequence();

		return true;
	}


	int componentsBitCount = inputBitmap.GetComponentBitsCount();
	if (componentsBitCount != 8){
		SendWarningMessage(0, "Only 8-bit images are supported");

		return false;
	}

	ibase::CSize inputBitmapSize(inputBitmap.GetImageSize());
	i2d::CRectangle realArea = i2d::CRectangle(inputBitmapSize);

	const i2d::IObject2d* usedAoiPtr = (aoiPtr != NULL)? aoiPtr: &realArea;

	iimg::CScanlineMask bitmapRegion;
	i2d::CRect clipArea(inputBitmap.GetImageSize());
	if (!bitmapRegion.CreateFromGeometry(*usedAoiPtr, &clipArea)){
		SendWarningMessage(0, "Cannot create the region");

		return false;
	}

	if (bitmapRegion.IsBitmapRegionEmpty()){
		SendWarningMessage(0, "Cannot process an empty region");
	
		return false;
	}

	i2d::CRect regionRect = bitmapRegion.GetBoundingBox();
	int regionTop = qMax(regionRect.GetTop(), 0);
	int regionBottom = qMin(regionRect.GetBottom(), inputBitmapSize.GetY());

	int pixelBytesCount = inputBitmap.GetComponentsCount();
	int usedColorComponents = pixelBytesCount;

	QStringList channelNames;

	int pixelFormat = inputBitmap.GetPixelFormat();
	switch (pixelFormat){
		case iimg::IBitmap::PF_GRAY:
			usedColorComponents = 1;
			channelNames << QCoreApplication::tr("Gray");
			break;

		case iimg::IBitmap::PF_RGB:
			usedColorComponents = 3;
			channelNames << QCoreApplication::tr("Red") << QCoreApplication::tr("Green") << QCoreApplication::tr("Blue");
			break;

		case iimg::IBitmap::PF_RGBA:
			usedColorComponents = 4;
			channelNames << QCoreApplication::tr("Alpha") << QCoreApplication::tr("Red") << QCoreApplication::tr("Green") << QCoreApplication::tr("Blue");
			break;
	}

	int histogramSize = 256 * usedColorComponents;

	istd::TDelPtr<quint32, istd::ArrayAccessor<quint32> > histogramDataPtr(new quint32[histogramSize]);
	quint32* histogramDataBufferPtr = histogramDataPtr.GetPtr();

	std::memset(histogramDataBufferPtr, 0, histogramSize * sizeof(quint32));
	int pixelCount = 0;

	for (int y = regionTop; y < regionBottom; y++){
		const quint8* inputLinePtr = (quint8*)inputBitmap.GetLinePtr(y);

		istd::CIntRanges::RangeList rangesList;
		const istd::CIntRanges* rangesPtr = bitmapRegion.GetPixelRanges(y);
		if (rangesPtr == NULL){
			continue;
		}

		rangesPtr->GetAsList(clipArea.GetHorizontalRange(), rangesList);

		for (		istd::CIntRanges::RangeList::ConstIterator iter = rangesList.begin();
					iter != rangesList.end();
					++iter){
			const istd::CIntRange& pixelRange = *iter;

			int rangeStart = qMax(pixelRange.GetMinValue(), 0);
			int rangeEnd = qMin(pixelRange.GetMaxValue(), inputBitmapSize.GetX());

			if (rangeEnd > rangeStart){
				const quint8* inputPixelPtr = inputLinePtr + rangeStart * pixelBytesCount;

				for (int x = rangeStart; x < rangeEnd; ++x){
					for (int componentIndex = 0; componentIndex < usedColorComponents; ++componentIndex){
						quint8 pixelComponentValue = inputPixelPtr[componentIndex];

						int mappedIndex = usedColorComponents - componentIndex - 1;

						++histogramDataBufferPtr[mappedIndex + pixelComponentValue * usedColorComponents];
					}

					inputPixelPtr += pixelBytesCount;
				}

				pixelCount += rangeEnd - rangeStart;
			}
		}
	}

	double normFactor = qPow(2.0, histogramPtr->GetSampleDepth()) - 1;

	for (int histIndex = 0; histIndex < histogramSize; histIndex++){
		double normHist = histogramDataBufferPtr[histIndex] / double(pixelCount);

		histogramDataBufferPtr[histIndex] = quint32(normHist * normFactor + 0.5);
	}

	istd::CChangeNotifier changePtr(histogramPtr);

	return histogramPtr->CreateDiscreteSequenceWithInfo(
					istd::TSmartPtr<const imeas::IDataSequenceInfo>(new HistogramChannelInfo(channelNames)),
					256,
					histogramDataPtr.PopPtr(),
					true,
					0,
					0,
					sizeof(quint32) * 8,
					usedColorComponents);
}


// public methods of the embedded class HistogramChannelInfo

CImageHistogramProcessorComp::HistogramChannelInfo::HistogramChannelInfo(const QStringList& channelNames)
	:m_channelNames(channelNames)
{
}


// reimplemented (imeas::INumericConstraints)

int CImageHistogramProcessorComp::HistogramChannelInfo::GetNumericValuesCount() const
{
	return m_channelNames.count();
}


QString CImageHistogramProcessorComp::HistogramChannelInfo::GetNumericValueName(int index) const
{
	Q_ASSERT(index >= 0);
	Q_ASSERT(index < m_channelNames.count());

	return m_channelNames[index];
}


QString CImageHistogramProcessorComp::HistogramChannelInfo::GetNumericValueDescription(int index) const
{
	return GetNumericValueName(index);
}


} // namespace iipr


