/********************************************************************************
**
**	Copyright (c) 2007-2011 Witold Gantzke & Kirill Lepskiy
**
**	This file is part of the ACF-Solutions Toolkit.
**
**	This file may be used under the terms of the GNU Lesser
**	General Public License version 2.1 as published by the Free Software
**	Foundation and appearing in the file LicenseLGPL.txt included in the
**	packaging of this file.  Please review the following information to
**	ensure the GNU Lesser General Public License version 2.1 requirements
**	will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
**	If you are unsure which license is appropriate for your use, please
**	contact us at info@imagingtools.de.
**
** 	See http://www.imagingtools.de, write info@imagingtools.de or contact
**	by Skype to ACF_infoline for further information about the ACF-Solutions.
**
********************************************************************************/


#include "iipr/CColorBitmapSeparatorSupplierComp.h"


namespace iipr
{


// reimplemented (iipr::IMultiBitmapProvider)

int CColorBitmapSeparatorSupplierComp::GetBitmapsCount() const
{
	const ProductType* productPtr = GetWorkProduct();
	if (productPtr != NULL){
		if (productPtr->IsEmpty()){
			return 1;
		}
		else{
			return productPtr->GetCount();
		}
	}

	return 0;
}


// reimplemented (iipr::IMultiBitmapProvider)

const iimg::IBitmap* CColorBitmapSeparatorSupplierComp::GetBitmap(int bitmapIndex) const
{
	const ProductType* productPtr = GetWorkProduct();
	if (productPtr != NULL){
		if (productPtr->IsEmpty()){
			Q_ASSERT(bitmapIndex == 0);

			if (m_bitmapProviderCompPtr.IsValid()){
				return m_bitmapProviderCompPtr->GetBitmap();
			}
		}
		else{
			Q_ASSERT(bitmapIndex < productPtr->GetCount());

			return productPtr->GetElementAt(bitmapIndex);
		}
	}

	return NULL;
}


// reimplemented (iipr::IMultiBitmapProvider)

const i2d::ITransformation2d* CColorBitmapSeparatorSupplierComp::GetLogTransform(int bitmapIndex) const
{
	return NULL;
}


// reimplemented (iproc::TSupplierCompWrap)

int CColorBitmapSeparatorSupplierComp::ProduceObject(ProductType& result) const
{
	if (!m_bitmapProviderCompPtr.IsValid()){
		return WS_CRITICAL;
	}

	const iimg::IBitmap* bitmapPtr = m_bitmapProviderCompPtr->GetBitmap();
	if (bitmapPtr == NULL){
		SendErrorMessage(0, "Input image could not be provided", "ColorBitmapSeparatorSupplier");

		return WS_ERROR;
	}

	result.Reset();	
	
	if (bitmapPtr->GetPixelFormat() != iimg::IBitmap::PF_RGB &&
		bitmapPtr->GetPixelFormat() != iimg::IBitmap::PF_RGBA)	{

			//There is only one chanel
			return WS_OK;
	}

	//Create chanels for RGB(A)
	istd::CIndex2d imageSize = bitmapPtr->GetImageSize();	

	//create red bitmap
	iimg::IBitmap* rOutputBitmapPtr = m_bitmapCompFact.CreateInstance();
	
	if(rOutputBitmapPtr == NULL){
		return WS_ERROR;
	}

	if(!rOutputBitmapPtr->CreateBitmap(iimg::IBitmap::PF_GRAY, imageSize)){
		return WS_ERROR;
	}

	//create green bitmap
	iimg::IBitmap* gOutputBitmapPtr = m_bitmapCompFact.CreateInstance();
	
	if(gOutputBitmapPtr == NULL){
		return WS_ERROR;
	}

	if(!gOutputBitmapPtr->CreateBitmap(iimg::IBitmap::PF_GRAY, imageSize)){
		return WS_ERROR;
	}

	//create blue bitmap
	iimg::IBitmap* bOutputBitmapPtr = m_bitmapCompFact.CreateInstance();
	
	if(bOutputBitmapPtr == NULL){
		return WS_ERROR;
	}

	if(!bOutputBitmapPtr->CreateBitmap(iimg::IBitmap::PF_GRAY, imageSize)){
		return WS_ERROR;
	}

	//create alpha bitmap
	iimg::IBitmap* aOutputBitmapPtr = NULL;
	
	if(bitmapPtr->GetPixelFormat() == iimg::IBitmap::PF_RGBA){

		if(m_createBitmapForAlpha.IsValid() && m_createBitmapForAlpha.GetAttributePtr()->GetValue()){

			aOutputBitmapPtr = m_bitmapCompFact.CreateInstance();
			
			if(aOutputBitmapPtr == NULL){
				return WS_ERROR;
			}

			if(!aOutputBitmapPtr->CreateBitmap(iimg::IBitmap::PF_GRAY, imageSize)){
				return WS_ERROR;
			}
		}
	}	

	int inputPixelComponentCount = bitmapPtr->GetComponentsCount();

	for (int y = 0; y < imageSize.GetY(); ++y){
		quint8* inputLinePtr = (quint8*)bitmapPtr->GetLinePtr(y);
		
		quint8* rOutputLinePtr = (quint8*)rOutputBitmapPtr->GetLinePtr(y);
		quint8* gOutputLinePtr = (quint8*)gOutputBitmapPtr->GetLinePtr(y);
		quint8* bOutputLinePtr = (quint8*)bOutputBitmapPtr->GetLinePtr(y);

		quint8* aOutputLinePtr = NULL;
		if(aOutputBitmapPtr != NULL){
			aOutputLinePtr = (quint8*)aOutputBitmapPtr->GetLinePtr(y);
		}

		for (int x = 0; x < imageSize.GetX(); ++x){
			quint8* pixelPtr = inputLinePtr + x * inputPixelComponentCount;

			rOutputLinePtr[x] = pixelPtr[0];
			gOutputLinePtr[x] = pixelPtr[1];
			bOutputLinePtr[x] = pixelPtr[2];

			if(aOutputLinePtr != NULL){
				aOutputLinePtr[x] = pixelPtr[3];
			}
		}
	}

	result.PushBack(rOutputBitmapPtr);
	result.PushBack(gOutputBitmapPtr);
	result.PushBack(bOutputBitmapPtr);

	if(aOutputBitmapPtr != NULL){
		result.PushBack(aOutputBitmapPtr);
	}

	return WS_OK;
}


// reimplemented (icomp::CComponentBase)

void CColorBitmapSeparatorSupplierComp::OnComponentCreated()
{
	BaseClass::OnComponentCreated();

	if (m_bitmapProviderModelCompPtr.IsValid()){
		RegisterSupplierInput(m_bitmapProviderModelCompPtr.GetPtr());
	}

	if (m_bitmapProviderModelCompPtr.IsValid()){
		RegisterSupplierInput(m_bitmapProviderModelCompPtr.GetPtr());
	}
}

} // namespace iipr


